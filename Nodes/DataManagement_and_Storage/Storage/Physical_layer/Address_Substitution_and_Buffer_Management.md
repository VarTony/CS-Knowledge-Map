---
title: Подмена адресов между памятью и вторичным хранилищем
description: Как операционные системы и СУБД подменяют адреса между RAM и диском. Виды стратегий подмены и что происходит, если в памяти находится блок с ссылкой на выгруженный участок.
tags:
  - memory_management
  - paging
  - dbms
  - address_translation
  - cache_management
---

# Подмена адресов между памятью и вторичным хранилищем

## Исторический контекст

Идея подмены адресов родилась в 60-е годы, когда стало ясно, что объём оперативной памяти всегда будет меньше объёма данных.  
Чтобы программы могли работать с массивами, превышающими физическую ОЗУ, инженеры придумали виртуальную память.  
Вместо прямых физических адресов процесс стал оперировать **виртуальными**, а система — решать, где реально находятся данные: в RAM или на диске.  

Позже этот принцип переняли СУБД.  
Они тоже начали подменять адреса, но уже на своём уровне: между страницами буфера в памяти и страницами таблиц на диске.  
Так возник механизм **буферного менеджера** (buffer manager) — сердце любой базы данных.

---

## Что такое подмена адресов

Подмена (remapping, aliasing, relocation) — это динамическое сопоставление адресов одного пространства с другими.  
Обычно участвуют три слоя:

| Уровень | Пространство адресов | Кто управляет |
|----------|----------------------|----------------|
| **MMU / ОС** | виртуальные страницы → физические фреймы в RAM | ядро |
| **Буферный менеджер СУБД** | логические страницы таблицы → страницы в buffer pool | СУБД |
| **Файловая система** | смещения в файле → блоки на диске | драйвер / kernel |

Каждый уровень хранит таблицу соответствий и имеет право подменить адрес:  
заменить «адрес на RAM» на «адрес на диск», когда нужно освободить память.

---

## Механизмы подмены

### 1. Страничная подкачка (OS level paging)
Классический вариант.  
ОС делит память на страницы (обычно 4 КБ).  
Когда страница не помещается в RAM, она сохраняется в swap-файл, а в таблице страниц ставится флаг ``P=0`` (не в памяти).  
При следующем обращении к этому адресу происходит **page fault**, и ОС загружает страницу обратно.

### 2. Буферизация в СУБД
СУБД реализует аналогичный механизм, но с большим контролем.  
Данные на диске разбиты на **страницы или блоки** (обычно 8 КБ).  
Когда запросу нужна страница, буферный менеджер проверяет:
- есть ли она в буфере;
- если нет — выбирает жертву (victim) и подменяет её на нужную страницу.

В таблице буфера (Buffer Table) меняются указатели:  
``page_id → frame_in_memory``  
а старая страница записывается обратно на диск, если была изменена (dirty).

### 3. Memory-mapped files
Смешанный подход, когда база данных или приложение не реализует собственный буфер, а использует системный mmap().  
В этом случае подменой занимается ОС, а не СУБД.  
Это проще, но менее детерминированно по контролю над кэшированием.

### 4. Segment swapping / demand loading
Редкий, но концептуальный вариант: подменяются не отдельные страницы, а целые сегменты (например, таблица или индекс).  
Используется в аналитических хранилищах, где выгодно загружать данные батчами.

---

## Виды стратегий подмены

Когда нужно выгрузить страницу, возникает вопрос: какую?  
Здесь работают **политики замещения (replacement policies)**.

| Политика | Идея | Пример использования |
|-----------|------|----------------------|
| **LRU (Least Recently Used)** | выгружается страница, к которой давно не обращались | PostgreSQL, ОС |
| **MRU (Most Recently Used)** | наоборот, вытесняется недавно использованная страница | специализированные СУБД |
| **Clock (Second Chance)** | упрощённый LRU с кольцевым указателем | Linux, InnoDB |
| **Random / FIFO** | простейшие подходы для систем с равномерным доступом | учебные модели |

Подмена всегда означает обновление таблицы соответствий, чтобы виртуальные адреса указывали на новые физические блоки.

---

## Адреса и ссылки при частичной загрузке

Теперь к более тонкой ситуации.

Представим, что в память загружен **блок данных А**,  
внутри которого есть ссылка на другой блок **B**,  
но B пока остаётся на диске.
```
A → B
```

В момент загрузки блока A СУБД не может разрешить эту ссылку напрямую.  
Поэтому она хранит не физический адрес, а **логический идентификатор** (page_id, oid, offset),  
который можно отобразить, если потребуется.  

Если код обращается к B, буферный менеджер:
1. обнаруживает, что нужного блока нет в памяти;
2. вызывает процедуру **fetch(page_id)**;
3. находит страницу B на диске и подгружает её в свободный или вытесненный фрейм;
4. обновляет таблицу отображений;
5. возвращает «живую» ссылку.

Таким образом, **ссылка в A временно указывает на “пустое место”**,  
пока блок B не будет подгружен и не получит физическое соответствие.

---

## Проблема двойной подмены

Иногда A и B взаимно ссылаются, и обе страницы могут быть выгружены.  
При повторной загрузке порядок важен:  
если A подгружена первой, её ссылки указывают на ещё несуществующие физические адреса.  
Поэтому большинство СУБД используют **таблицу дескрипторов страниц**,  
где каждая страница получает постоянный логический идентификатор,  
а физическая привязка подменяется при загрузке.  

```
| page_id | frame | dirty | pin_count |
| ------- | ----- | ----- | --------- |
| 42      | 7     | 0     | 1         |
| 43      | null  | 0     | 0         |
```


Пока страница 43 (B) не в памяти, поле frame=null,  
и все ссылки на неё остаются логическими.

---

## Ленивая подгрузка и отложенные ссылки

СУБД и ОС часто используют **lazy loading**:  
страницы загружаются только при первом доступе.  
Это экономит память и ускоряет старт программы, но создаёт момент временной «дырки» —  
в памяти может быть структура, указывающая на несуществующие в RAM объекты.  

Обычно это решается тремя способами:
1. **Дескрипторы** — ссылки указывают не на объект, а на дескриптор, который знает, где взять данные.
2. **Page fault** — аппаратное исключение, перехватываемое ОС при доступе к отсутствующей странице.
3. **Handle / proxy-объекты** — программная прослойка, которая при первом вызове сама загружает нужный блок.

---

## Сводная таблица

| Механизм | Уровень | Что подменяется | Реакция при обращении к отсутствующим данным |
|-----------|----------|----------------|---------------------------------------------|
| **Paging** | ОС | виртуальная страница → RAM frame | page fault + подкачка |
| **Buffer Manager** | СУБД | page_id → buffer frame | fetch + запись старой страницы |
| **Memory-mapped I/O** | ОС / FS | файл → память | аппаратный page fault |
| **Handle / Proxy** | Приложение | ссылка → lazy объект | загрузка при первом доступе |

---

## Итог

Механизм подмены адресов позволяет системе работать с данными,  
которые физически не помещаются в оперативную память.  
На уровне ОС это — страничная подкачка;  
на уровне СУБД — буферный менеджер;  
на уровне программы — ленивые ссылки и прокси-объекты.  

Когда в памяти находится блок с подменёнными ссылками,  
а по одной из них запрошен выгруженный объект,  
система «доразворачивает» адресное пространство:  
выгружает ненужные страницы, подгружает нужную,  
и обновляет все связи.  

Таким образом, подмена — это не ошибка, а фундаментальный механизм  
балансировки между скоростью RAM и ёмкостью диска.

---

## Смежные темы

- [Виртуальная, физическая память и таблицы адресов](./Virtual_Physical_Memory_and_Address_Tables.md) 
- [Модель внешней памяти (I/O-модель)](../Theory/ExternalMemoryModel.md)
- [Геометрия пластин и организация данных на магнитных дисках](./DiskGeometry.md)
- [Размещение и выравнивание записей в блоках СУБД](./Record_Alignment_and_Page_Storage.md)
- [Внешние сортировки и TPMMS](../../Algorithms/TPMMS.md)
