---
title: Подмена адресов между памятью и вторичным хранилищем
description: Как операционные системы и СУБД подменяют адреса между RAM и диском. Виды стратегий подмены и что происходит, если в памяти находится блок с ссылкой на выгруженный участок.
tags:
  - memory_management
  - paging
  - dbms
  - address_translation
  - cache_management
---

# Подмена адресов между памятью и вторичным хранилищем

## Исторический контекст

Идея подмены адресов родилась в 60-е годы, когда стало ясно, что объём оперативной памяти всегда будет меньше объёма данных.  
Чтобы программы могли работать с массивами, превышающими физическую ОЗУ, инженеры придумали виртуальную память.  
Вместо прямых физических адресов процесс стал оперировать **виртуальными**, а система — решать, где реально находятся данные: в RAM или на диске.  

Позже этот принцип переняли СУБД.  
Они тоже начали подменять адреса, но уже на своём уровне: между страницами буфера в памяти и страницами таблиц на диске.  
Так возник механизм **буферного менеджера** (buffer manager) — сердце любой базы данных.

---

## Что такое подмена адресов

Подмена (remapping, aliasing, relocation) — это динамическое сопоставление адресов одного пространства с другими.  
Обычно участвуют три слоя:

| Уровень | Пространство адресов | Кто управляет |
|----------|----------------------|----------------|
| **MMU / ОС** | виртуальные страницы → физические фреймы в RAM | ядро |
| **Буферный менеджер СУБД** | логические страницы таблицы → страницы в buffer pool | СУБД |
| **Файловая система** | смещения в файле → блоки на диске | драйвер / kernel |

Каждый уровень хранит таблицу соответствий и имеет право подменить адрес:  
заменить «адрес на RAM» на «адрес на диск», когда нужно освободить память.

---

## Механизмы подмены

### 1. Страничная подкачка (OS level paging)
Классический вариант.  
ОС делит память на страницы (обычно 4 КБ).  
Когда страница не помещается в RAM, она сохраняется в swap-файл, а в таблице страниц ставится флаг ``P=0`` (не в памяти).  
При следующем обращении к этому адресу происходит **page fault**, и ОС загружает страницу обратно.

### 2. Буферизация в СУБД
СУБД реализует аналогичный механизм, но с большим контролем.  
Данные на диске разбиты на **страницы или блоки** (обычно 8 КБ).  
Когда запросу нужна страница, буферный менеджер проверяет:
- есть ли она в буфере;
- если нет — выбирает жертву (victim) и подменяет её на нужную страницу.

В таблице буфера (Buffer Table) меняются указатели:  
``page_id → frame_in_memory``  
а старая страница записывается обратно на диск, если была изменена (dirty).

### 3. Memory-mapped files
Смешанный подход, когда база данных или приложение не реализует собственный буфер, а использует системный mmap().  
В этом случае подменой занимается ОС, а не СУБД.  
Это проще, но менее детерминированно по контролю над кэшированием.

### 4. Segment swapping / demand loading
Редкий, но концептуальный вариант: подменяются не отдельные страницы, а целые сегменты (например, таблица или индекс).  
Используется в аналитических хранилищах, где выгодно загружать данные батчами.

---

## Виды стратегий подмены

Когда нужно выгрузить страницу, возникает вопрос: какую?  
Здесь работают **политики замещения (replacement policies)**.

| Политика | Идея | Пример использования |
|-----------|------|----------------------|
| **LRU (Least Recently Used)** | выгружается страница, к которой давно не обращались | PostgreSQL, ОС |
| **MRU (Most Recently Used)** | наоборот, вытесняется недавно использованная страница | специализированные СУБД |
| **Clock (Second Chance)** | упрощённый LRU с кольцевым указателем | Linux, InnoDB |
| **Random / FIFO** | простейшие подходы для систем с равномерным доступом | учебные модели |

Подмена всегда означает обновление таблицы соответствий, чтобы виртуальные адреса указывали на новые физические блоки.


Также стоит отметить, что подмена может быть автоматической — когда при загрузке блока в память автоматически подменяются все ссылки во внутренних записях, ссылающиеся на записи внутри блока. Подмена по требованию — когда нет общей проактивной подмены адресов, и она осуществляется по конкретному требованию; например, ссылки подменяются только в тех записях, которые, предположительно, будут многократно использоваться, а остальные либо не получат подмену вовсе, либо получат её при единичном обращении. Есть и вариант полного отказа от подмены, но в таком случае за записями придётся обращаться к вторичному устройству, а это довольно дорогая операция как по времени, так и по вычислительным ресурсам по сравнению с обращением в оперативной памяти.

---

## Адреса и ссылки при частичной загрузке

Теперь к более тонкой ситуации.

Представим, что в память загружен **блок данных А**,  
внутри которого есть ссылка на другой блок **B**,  
но B пока остаётся на диске.
```
A → B
```

В момент загрузки блока A СУБД не может разрешить эту ссылку напрямую.  
Поэтому она хранит не физический адрес, а **логический идентификатор** (page_id, oid, offset),  
который можно отобразить, если потребуется.  

Если код обращается к B, буферный менеджер:
1. обнаруживает, что нужного блока нет в памяти;
2. вызывает процедуру **fetch(page_id)**;
3. находит страницу B на диске и подгружает её в свободный или вытесненный фрейм;
4. обновляет таблицу отображений;
5. возвращает «живую» ссылку.

Таким образом, **ссылка в A временно указывает на “пустое место”**,  
пока блок B не будет подгружен и не получит физическое соответствие.

---

## Проблема двойной подмены

Иногда A и B взаимно ссылаются, и обе страницы могут быть выгружены.  
При повторной загрузке порядок важен:  
если A подгружена первой, её ссылки указывают на ещё несуществующие физические адреса.  
Поэтому большинство СУБД используют **таблицу дескрипторов страниц**,  
где каждая страница получает постоянный логический идентификатор,  
а физическая привязка подменяется при загрузке.  

```
| page_id | frame | dirty | pin_count |
| ------- | ----- | ----- | --------- |
| 42      | 7     | 0     | 1         |
| 43      | null  | 0     | 0         |
```


Пока страница 43 (B) не в памяти, поле frame=null,  
и все ссылки на неё остаются логическими.

---

## Ленивая подгрузка и отложенные ссылки

СУБД и ОС часто используют **lazy loading**:  
страницы загружаются только при первом доступе.  
Это экономит память и ускоряет старт программы, но создаёт момент временной «дырки» —  
в памяти может быть структура, указывающая на несуществующие в RAM объекты.  

Обычно это решается тремя способами:
1. **Дескрипторы** — ссылки указывают не на объект, а на дескриптор, который знает, где взять данные.
2. **Page fault** — аппаратное исключение, перехватываемое ОС при доступе к отсутствующей странице.
3. **Handle / proxy-объекты** — программная прослойка, которая при первом вызове сама загружает нужный блок.

---

### Обратная операция подмены адресов

Так же, как и прямая подмена адресов при загрузке блока с вторичного носителя в оперативную память, существует обратная операция — подмена при сохранении данных из памяти на диск. При этом выполняется зеркальное преобразование: все внутренние ссылки (указатели), указывавшие на объекты в оперативной памяти, заменяются на их долговременные идентификаторы или физические адреса на вторичном носителе (например, смещения в файле или блок-идентификаторы). Это необходимо, чтобы после записи блока на диск его содержимое можно было корректно интерпретировать и переиндексировать без зависимости от текущих адресов в RAM.
Особое внимание требуется при работе с закреплёнными (pinned) блоками — это блоки, на которые существуют ссылки из других областей памяти и которые, следовательно, нельзя выгрузить или менять их адреса без координации. Перед выполнением обратной подмены менеджер памяти или подсистема ввода-вывода должна пометить блок как «в процессе записи», установить необходимые блокировки (или инкрементировать счётчик закреплений), чтобы исключить параллельную модификацию и одновременную выгрузку. Только после того, как все внешние ссылки гарантированно консистентны и никакие операции записи в этот блок не идут, можно начать преобразование внутренних указателей и сериализацию.
Чтобы обеспечить атомарность и устойчивость к сбоям, обычно применяют журналирование (WAL) или транзакционный подход: сначала фиксируется намерение записи (entry в журнале), затем выполняется замена внутренних ссылок на долговременные адреса и запись данных на диск, и только после успешного завершения операции пометка о записи применяется окончательно. В противном случае при падении системы можно получить несогласованное состояние — например, часть ссылок уже будет указывать на «диск-адреса», часть — на RAM-адреса, и блок окажется некорректным до восстановления из лога.
С практической точки зрения существует несколько стратегий обратной подмены:
** eager (проактивная) запись/подмена** — при выгрузке блока немедленно выполняется полная подмена всех ссылок и полная запись на диск; даёт более предсказуемую целостность, но увеличивает задержки записи;
lazy (по требованию) — подмена и запись выполняются только для тех ссылок/подструктур, которые действительно изменялись или ожидаются к частому использованию; снижает I/O, но усложняет логику согласованности;
отказ от подмены — данные записываются в формате, где сохранённые ссылки остаются «персистентными идентификаторами» и разрешаются при последующей загрузке; это просто и дешево по записи, но приводит к затратам при чтении (необходимо разрешать идентификаторы и, возможно, повторно загружать зависимости).
Наконец, при многопоточном или распределённом окружении нужно продумать механизмы синхронизации и версионирования: например, использовать оптимистичную проверку версий (compare-and-swap по метаданным блока), референс-счётчики для управления закреплением, или двухфазные протоколы (2PC) при записи взаимосвязанных блоков на разных устройствах. Всё это помогает избежать гонок, потери ссылок и необходимости дорогостоящих откатов после неудачных операций записи.

---

## Сводная таблица

| Механизм | Уровень | Что подменяется | Реакция при обращении к отсутствующим данным |
|-----------|----------|----------------|---------------------------------------------|
| **Paging** | ОС | виртуальная страница → RAM frame | page fault + подкачка |
| **Buffer Manager** | СУБД | page_id → buffer frame | fetch + запись старой страницы |
| **Memory-mapped I/O** | ОС / FS | файл → память | аппаратный page fault |
| **Handle / Proxy** | Приложение | ссылка → lazy объект | загрузка при первом доступе |

---

## Итог

Механизм подмены адресов позволяет системе работать с данными,  
которые физически не помещаются в оперативную память.  
На уровне ОС это — страничная подкачка;  
на уровне СУБД — буферный менеджер;  
на уровне программы — ленивые ссылки и прокси-объекты.  

Когда в памяти находится блок с подменёнными ссылками,  
а по одной из них запрошен выгруженный объект,  
система «доразворачивает» адресное пространство:  
выгружает ненужные страницы, подгружает нужную,  
и обновляет все связи.  

Таким образом, подмена — это не ошибка, а фундаментальный механизм  
балансировки между скоростью RAM и ёмкостью диска.

---

## Смежные темы

- [Виртуальная, физическая память и таблицы адресов](./Virtual_Physical_Memory_and_Address_Tables.md) 
- [Модель внешней памяти (I/O-модель)](../Theory/ExternalMemoryModel.md)
- [Буфер-менеджер (компонент СУБД)](../../DBMS/Fundamenral/Components/Buffer_Manager.md)
- [Геометрия пластин и организация данных на магнитных дисках](./DiskGeometry.md)
- [Размещение и выравнивание записей в блоках СУБД](./Record_Alignment_and_Page_Storage.md)
- [Внешние сортировки и TPMMS](../../Algorithms/TPMMS.md)