---
title: Виртуальная, физическая память и таблицы адресов
description: Как устроена адресация, трансляция адресов, таблицы страниц и управление памятью в многослойных системах. Почему tombstone ставится в указатель, а не в память.
tags:
  - memory_management
  - dbms
  - virtual_memory
  - page_table
  - tombstone
---

# Виртуальная, физическая память и таблицы адресов

## Контекст

Когда говорят о памяти, чаще всего имеют в виду «оперативку», но в реальности она — лишь один уровень в многоступенчатой системе хранения данных.  
Любая программа оперирует **логическими адресами** — абстракцией, за которой стоит сложный механизм сопоставления виртуальных, физических и дисковых пространств.  
Это сопоставление обеспечивает **MMU (Memory Management Unit)** и набор **таблиц страниц**, которые переводят виртуальные адреса в физические.

---

## Виды памяти и их взаимосвязь

Современные архитектуры используют трёхуровневую модель:

| Уровень | Описание | Размер адреса |
|----------|-----------|----------------|
| **Логическая память** | Адреса, с которыми работает процесс — указатели и смещения | 32 бита (4 байта) |
| **Физическая память (RAM)** | Реальные ячейки ОЗУ, куда загружаются страницы | зависит от объёма ОЗУ |
| **Вторичная память (Disk, SSD)** | Хранит выгруженные страницы, swap, файлы данных | 64 бита (8 байт и выше) |

Процессор видит только виртуальные адреса.  
MMU, пользуясь таблицами страниц, решает, где реально лежит каждый кусок данных — в RAM или на диске.

---

## Структура адреса

Виртуальный адрес делится на две части:

- **номер страницы (page number)** — индекс страницы в виртуальном пространстве;  
- **смещение (offset)** — положение внутри страницы.

``Адрес = [номер страницы | смещение]``

Например, при размере страницы 4 КБ (2¹² байт) и 32-битной адресации:
- старшие 20 бит отвечают за номер страницы;
- младшие 12 — за смещение внутри неё.

---

## Таблицы отображения

Трансляция адресов опирается на несколько структур.

### 1. Page Table (таблица страниц)
Сопоставляет виртуальные номера страниц с физическими фреймами RAM.  
Каждая запись содержит:
- адрес фрейма;
- биты доступа (чтение/запись);
- бит присутствия (present);
- флаги защиты.

### 2. Segment Table
Используется в архитектурах с сегментной памятью.  
Каждый сегмент хранит базу и длину, физический адрес вычисляется как:  
``Physical = Base(segment) + Offset``

### 3. Offset-таблицы в СУБД
В хранилищах вроде PostgreSQL смещения используются для отображения логических блоков в физические позиции на диске.  
Это аналог page table, но на уровне файловой системы.

---

## 32-битные адреса и огромные диски

Здесь возникает кажущееся противоречие:  
если процессор оперирует 32-битными адресами (4 ГБ),  
как он может работать с терабайтами данных?

Ответ — **в подмене содержимого страниц во времени**, а не в увеличении числа адресов.  
Адресов действительно 4 миллиарда, но таблицы страниц могут указывать на **разные данные в разное время**.  
Это как окна, за которыми ОС показывает разные куски диска.
```
виртуальный адрес 0x2000 → RAM (frame #12)
виртуальный адрес 0x3000 → SWAP (disk offset 0x001A3C)
```


Когда процесс обращается к странице, которой нет в памяти, происходит **page fault**:  
ОС выгружает один фрейм, а на его место загружает нужный с диска.  
Так 4 ГБ виртуального пространства могут обслуживать сотни гигабайт данных, просто не одновременно.

---

## Почему на диске нужны 8-байтные адреса

Адрес в RAM — это смещение в пределах нескольких гигабайт,  
а адрес на диске может указывать на блоки в терабайтах.  
Поэтому таблицы подкачки (swap map) используют 64-битные смещения:

```вирт. страница #1234 → физ. блок #000000ABCD0123```

---

## Где хранятся таблицы и что они занимают

Таблицы страниц хранятся в оперативной памяти, и на них реально уходит заметная доля RAM.

При 4-КБ страницах и 32-битной адресации:

```4 ГБ / 4 КБ = 1 048 576 страниц```  
Каждая запись (PTE) — 8 байт  
```1 048 576 * 8 байт ≈ 8 МБ```

Итого: **около 8 МБ ОЗУ** требуется, чтобы описать полное 4-гигабайтное пространство.

Быстрые копии этих записей хранятся в **TLB (Translation Lookaside Buffer)** —  
кэше внутри процессора, который ускоряет повторные трансляции.

---

## Как распределена оперативная память

Всё физическое ОЗУ делится динамически, но в среднем выглядит так:

```
┌──────────────────────────────────────────────────────────────┐
│ Kernel space (ядро, таблицы страниц, драйверы) ≈10% │
├──────────────────────────────────────────────────────────────┤
│ Disk & file caches (page cache, buffer cache) ≈20–30%│
├──────────────────────────────────────────────────────────────┤
│ User space (heap, stack, code, data) ≈60%+ │
└──────────────────────────────────────────────────────────────┘
```


- **Таблицы страниц** и системные структуры занимают часть kernel space.  
- **Page cache** хранит недавно прочитанные страницы с диска.  
- **Buffer cache** держит временные блоки для записи.  
- Всё остальное отдано процессам.

---

## Tombstone и защита указателей

Когда программа освобождает память, старые указатели становятся опасными:  
они всё ещё содержат старые адреса и могут случайно попасть на другую структуру.  
Чтобы этого не происходило, используется **tombstone-механизм** —  
не в памяти, а **в самих указателях**.

После удаления объект исчезает, а указатель получает специальное значение:
```
ptr = TOMBSTONE // вместо старого адреса
```


Это гарантирует, что попытка обращения вызовет ошибку или проверку,  
а не обращение в чужую область памяти.  

Для отладки могут также заполняться сами освобождённые области шаблоном (`0xDEADBEEF`),  
но это уже техника memory poisoning, а не tombstone.

---

## Итог

| Компонент | Роль |
|------------|------|
| **Page Table** | Отображает виртуальные страницы в физические фреймы |
| **TLB** | Кэширует недавние трансляции |
| **Page / Buffer Cache** | Хранит копии файлов и блоков диска в RAM |
| **Tombstone** | Маркер в указателе, предотвращающий обращение к освобождённой памяти |
| **Kernel Space** | Управление памятью, драйвера, системные буферы |

---

## Смысл в целом

Память — это не просто набор ячеек, а система взаимосвязей и соглашений:  
виртуальные адреса — это абстракция,  
таблицы страниц — их отображение,  
а буферы и кэши — живой слой между RAM и диском.  
Даже при 4 ГБ адресов ОС может управлять терабайтами данных,  
просто меняя содержимое этих адресов во времени.

---

## Смежные темы

- [Модель внешней памяти (External Memory Model, I/O-модель)](../Theory/ExternalMemoryModel.md)  
- [Геометрия пластин и организация данных на магнитных дисках](./DiskGeometry.md)
