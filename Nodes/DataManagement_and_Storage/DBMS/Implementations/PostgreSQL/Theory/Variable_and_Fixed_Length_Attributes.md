---
title: Фиксированные и переменные типы атрибутов
subtitle: Влияние на физическое хранение и производительность
---

# Фиксированные и переменные типы атрибутов в PostgreSQL

Выбор между `CHAR(n)` и `TEXT` кажется вопросом вкуса, но под ним скрывается одна из старейших дилемм проектирования СУБД: **предсказуемость против адаптивности**.
Эта тема уходит корнями во времена, когда каждая страница хранилища имела фиксированный объём, а движок стремился к максимальной предсказыемости того, сколько строк поместится внутрь каждого блока.

---

## Ранние системы и культ фиксированной длины

В классических СУБД 70–80-х годов преобладали **fixed-length records** — записи фиксированной длины.
Такой подход позволял:

* быстро вычислять смещение строки по её порядковому номеру;
* легко перескакивать между страницами;
* оценивать плотность таблицы и выполнять выборку без дополнительных указателей.

Но он имел и очевидные минусы: даже если поле «имя» занимало всего три символа, СУБД резервировала под него весь объём — скажем, 256 байт.
Неиспользованное место заполнялось **padding’ом** — пробельными байтами, формируя ложное ощущение порядка за счёт пустоты.

---

## Переменная длина и varlena-структуры

PostgreSQL изначально отошёл от догм фиксированных записей.
Его архитектура хранения базируется на идее **tuple variable length** — каждая запись может состоять из атрибутов разной длины, а каждый такой атрибут может храниться в формате **varlena** (*variable length*).

Varlenа-поле имеет небольшой заголовок (1–4 байта), где записана его длина.
Дальше следуют реальные данные — без заполнения до фиксированного размера.
Благодаря этому, поле `TEXT` с коротким значением действительно занимает столько, сколько нужно, и ни байтом больше.

---

## Влияние на физическое хранение

Фиксированные типы (`CHAR(n)`) обеспечивают **стабильный размер строки**.
Это упрощает расчёт вместимости страницы и делает heap-файл более детерминированным:
движок может заранее знать, сколько tuple уместится в 8-килобайтный блок.
Такой предсказуемый layout упрощает статистику и снижает риск расхождения между оценкой и фактическим объёмом.

Переменные типы (`TEXT`, `VARCHAR`) приносят обратную сторону —
они экономят место, но вносят **непредсказуемость при модификациях**.
Когда строка растёт (например, имя пользователя меняется с “Ира” на “Александра”), tuple может не поместиться в ту же страницу.
Postgres вынужден создавать новую запись, а старую помечать как “мертвую” — отсюда **bloat**, фрагментация и работа для VACUUM.

---

## OLTP-реальность

В системах OLTP, где миллионы коротких строк часто читаются и редко обновляются, компромисс очевиден:
экономия диска и кэша важнее идеальной геометрии страниц.
Использование `TEXT` или `VARCHAR(n)` снижает I/O-нагрузку, уменьшает размер индексов и ускоряет чтение.

Фиксированные типы оправданы там, где структура данных стабильна, а объём записей заранее известен — например, в телеком-системах или низкоуровневых форматах логов, где нужна побайтовая предсказуемость.

---

## Итог

`CHAR(n)`, `TEXT` и `VARCHAR(n)`.
Первый дает детерминизм в выделение памяти под блоки страницы.
Второй и третий позволяют за счет своей гибкости не устанавливать жестких ограничений на размерность поля
и экономить тем самым свободное пространство на пластине, благодаря тому, что не нужно заполнять "байтами-пустышками" не используемое пространство в его границах.
Таким образом `CHAR(n)` стоит использовать когда известна размерность предпологиемых данных и эти данные с высокой вероятностью будут подвержены частым изменениям. Например это может быть регулярно сменяемый идентификатор последнего платежа.
В большинстве сценариев как в OLAP так и в OLTP структурах будет подходить в качестве строкового типа `TEXT` или `VARCHAR(n)`


---

## Связанные темы

- [TOAST: хранение больших атрибутов](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/TOAST.md)
- [HEAP-файлы](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/HEAP_Files.md)
- [VACUUM](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/VACUUM.md)
- [Varlena](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Logic_internals/Varlena_Format.md)


