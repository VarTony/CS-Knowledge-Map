---
title: TOAST или - 'слишком большие данные обжариваются отдельно'
---

# TOAST: история появления и архитектура хранения больших данных в PostgreSQL

Когда PostgreSQL только формировался как система, у него, как и у большинства ранних реляционно подобных баз, стояла простая цель — хранить записи в пределах одной физической страницы. Каждая страница имела фиксированный размер (8 КБ), и все строки целиком должны были помещаться внутрь неё. Это решение выглядело естественным: страница была минимальной единицей ввода-вывода, и обращаться к ней можно было напрямую, не ломая структуру heap-файла.

Но уже к концу 90-х стало очевидно, что этого подхода не хватает. С ростом веб-приложений и первых мультимедийных систем пользователи начали сохранять в БД всё подряд: тексты, изображения, JSON-структуры, архивы — и размер одной строки стал выходить далеко за пределы 8 КБ.

---

## До TOAST: Архаичные приёмы сегментации

До появления TOAST PostgreSQL пользовался достаточно грубым, но понятным способом размещения больших данных. Если значение не помещалось в одну страницу, оно **дробилось на фрагменты**, которые укладывались в **соседние блоки**.

В каждой странице хранился заголовок с **ссылками на “ранки”** — то есть части исходного значения, разбросанные по страницам. При чтении СУБД должна была собирать их заново, как мозаику.

Эта идея выглядела естественным компромиссом, но имела массу побочных эффектов:

* добавляла накладные расходы при чтении — требовалось много случайных обращений к диску;
* усложняла обновление строк — любое изменение заставляло переписывать всю цепочку блоков;
* мешала вакууму и индексации — ведь куски одной записи могли оказаться в совершенно разных местах файла.

К началу 2000-х стало ясно, что такая модель больше не выдерживает нагрузок. Именно тогда в версии PostgreSQL 7.1 появилась новая система хранения больших значений — **TOAST**.

---

## TOAST: идея и принцип работы

TOAST — это сокращение от **“The Oversized-Attribute Storage Technique”**, буквально «техника хранения слишком больших атрибутов».
Название родилось в шутливой манере, характерной для университетской среды Berkeley, где развивался PostgreSQL: “oversized attributes are toasted” — *“слишком большие данные обжариваются отдельно”*.

Суть TOAST в том, что PostgreSQL перестаёт пытаться втиснуть все данные в одну страницу.
Вместо этого он **создаёт для каждой таблицы скрытую вспомогательную таблицу** (`pg_toast_<oid>`), где хранятся крупные значения в сжатом и сегментированном виде.
А в основной таблице остаётся лишь **небольшая ссылка** — OID-указатель на соответствующую строку внутри TOAST-хранилища.

---

## Как работает механизм TOAST

Каждый атрибут переменной длины (тип `text`, `jsonb`, `bytea`, `xml` и т.д.) проходит несколько стадий перед записью:

1. **Попытка поместиться в страницу.**
   Если вся строка (включая заголовки) занимает не более **~2 КБ**, она хранится как есть.

2. **Сжатие (pglz).**
   Если значение больше порога, PostgreSQL пытается его сжать встроенным алгоритмом `pglz`.
   Если после сжатия оно стало достаточно компактным — остаётся в той же странице.

3. **TOAST-ирование.**
   Если и после сжатия строка не помещается, PostgreSQL переносит значение во **вспомогательную TOAST-таблицу**, разбивая его на фрагменты (по умолчанию по 2 КБ).
   В основной таблице хранится лишь ссылка (pointer) на эти фрагменты.

Всё это происходит **прозрачно** для пользователя: при чтении или обновлении строк Postgres сам решает, когда “поджарить” значение и когда собрать его обратно.

---

## Когда активируется TOAST

На практике механизм TOAST начинает работать,
когда суммарный размер одной строки превышает **около 2 КБ** полезных данных (точнее — порог определяется параметром `TOAST_TUPLE_TARGET`, обычно = 2 048 байт).

До этого момента PostgreSQL старается удержать значение прямо в heap-странице, чтобы избежать лишних обращений к TOAST-таблице.

---

## Зачем это нужно и какие преимущества даёт

* **Контроль над I/O.** Большие объекты не распирают страницы heap’а, чтение обычных строк остаётся быстрым.
* **Прозрачность.** Для пользователя механизм полностью невидим: запросы не меняются.
* **Компрессия.** Большие атрибуты автоматически сжимаются, уменьшая размер базы.
* **Простота обслуживания.** Каждая TOAST-таблица — это обычная таблица PostgreSQL, обслуживаемая `VACUUM`, `ANALYZE` и `REINDEX` как и все остальные.

---

## Итог

TOAST — это одно из тех архитектурных решений, которые позволили PostgreSQL получить весомые преимущества в рамках классических SQL-ориентированых систем.

Раньше большие данные приходилось **разрывать**, управляя заголовками и адресами фрагментов; теперь же это делатся — **умно, лениво и прозрачно**, сохраняя согласованность heap-файлов и эффективность чтения.

Ироничное имя “TOAST” стало удачной метафорой:
Postgres действительно “обжаривает” слишком большие куски данных отдельно, чтобы основное блюдо — heap-страница — оставалось "лёгко усваеваемо".

## Связанные темы

- [HEAP файлы](./HEAP_Files.md)
- [Размер блока данных и скорость чтения с диска](/DataManagement_and_Storage/Storage/Physical_layer/BlockSize_and_IO_Performance.md)