---
title: VACUUM - или как PostgreSQL деформатирует и очищает блоки своих страниц
---

# VACUUM: как PostgreSQL деформатирует и очищает блоки своих страниц

Если смотреть на PostgreSQL как на файловую систему, то VACUUM — её дефрагментатор. Процесс, благодаря которому база остаётся работоспособной, не зарастая мёртвыми версиями данных.

Чтобы понять, зачем он вообще нужен, нужно вспомнить, на чём построен весь внутренний механизм PostgreSQL — **многоверсионность (MVCC)**. Каждый `UPDATE` или `DELETE` не перезаписывает строку, а создаёт новую версию. Старая при этом помечается как “недействительная”, но физически остаётся в файле таблицы. Со временем таких мёртвых строк накапливается всё больше, и страницы таблицы начинают напоминать чердак, забитый старыми вещами: вроде бы места еще достаточно, но структурировать становится сложнее.

---

## Историческая предпосылка

Название **VACUUM** появилось не случайно. Оно восходит к английскому слову *vacuum* — “вакуумировать”, “откачивать воздух”, “пылесосить”.
В старых документах Berkeley Postgres (ещё до того, как проект стал PostgreSQL) разработчики описывали процедуру, которая должна “откачать мусорные tuple из heap-файла” — *“to vacuum out dead tuples from heap relations”*.
Отсюда и возникло: **VACUUM** — буквально “высасывает мусор” из страниц таблицы.

Когда Postgres только переходил от академического прототипа к промышленной СУБД (в 90-е), альтернатив было две: либо реализовать сборщик мусора в реальном времени, как в языках программирования, либо проводить периодическую чистку. Выбрали второе — как более контролируемое и планируемое заранее.

---

## Что делает VACUUM

На логическом уровне VACUUM:

1. Находит кортежи (строки), которые больше не видны ни одной активной транзакции.
2. Помечает их как удалённые.
3. Освобождает место на странице, чтобы оно могло быть использовано под новые вставки.

Но на физическом уровне всё интереснее.

---

## Внутренний цикл: работа с heap-страницами

Каждая таблица хранится в виде heap-файла — набора страниц по 8 КБ. VACUUM проходит их последовательно,
и для каждой страницы:

1. **Читает её в буфер** (через Buffer Manager).
2. Проверяет все tuple, сверяя их `xmin` и `xmax` — идентификаторы транзакций.
3. Если строка недействительна и больше никем не видна, помечает её как свободную.
4. Обновляет карту свободного пространства (FSM — Free Space Map).

Но важно: VACUUM **не дефрагментирует физически страницу**. Он не сжимает содержимое и не перестраивает файл.
Он просто обозначает участки, куда можно писать.
Это как если бы на чердаке не выбрасывали мусор, а просто отметили не нужные вещи в коробках — “сюда можно положить что-то новое вместо них”.

---

## Где же дефрагментация?

По-настоящему физическая дефрагментация выполняется другой командой — **VACUUM FULL**.
Она создаёт **новую копию таблицы**, в которую записывает только актуальные строки, последовательно, без "дыр".
А старую таблицу затем удаляет.
Это аналог “сжатия диска”: освобождается место, страницы становятся плотными, и последовательное чтение ускоряется.

Разница принципиальна:

| Команда       | Что делает                                        | Блокировка                        | Итог                           |
| ------------- | ------------------------------------------------- | --------------------------------- | ------------------------------ |
| `VACUUM`      | Удаляет метки мёртвых строк, оставляя структуру   | Нет                               | Быстрая “уборка”               |
| `VACUUM FULL` | Перезаписывает таблицу заново                     | Да                                | Полная дефрагментация          |
| `pg_repack`   | Перестраивает таблицу без эксклюзивной блокировки | Минимальная (на финальном rename) | Безостановочная дефрагментация |

pg_repack — дефрагментация без блокировок
В больших системах есть проблема: VACUUM FULL останавливает работу таблицы, а без него таблица постепенно пухнет от мёртвых строк, — разработчики нашли изящный обходной путь. Так родился pg_repack.
Он считывает постранично файл таблицы, блокируя только, те страницы из которых в текущий момент производится чтение и создаёт временную копию таблицы, копируя туда только актуальные кортежи, при этом параллельно следит за изменениями через триггеры.
Пока приложение продолжает читать и писать, pg_repack подхватывает новые изменения и применяет их к новой таблице.
Когда всё готово —  подключается repack_swap (C-функция), которая обновляет системные каталоги — меняет relfilenode, OID, связи с TOAST-таблицей, индексы, зависимости — чтобы новая таблица стала “старой”, а старая ушла на удаление в контексте одной транзакции. В этот момент все же случится блокировка.
С точки зрения диска — это та же самая полная дефрагментация, что делает VACUUM FULL,
но без долгой блокировки и простоя.

---

## Почему фрагментация вообще возникает

Когда PostgreSQL обновляет строку, он создаёт её новую версию где угодно — чаще всего в конце файла.
Старая версия остаётся на странице, но уже “мертвая”.
В результате структура таблицы постепенно "разбухает", а физические блоки, из которых она состоит, 
всё больше теряют в последовательности.

С точки зрения устройства хранения это выглядит так:

```
Пластины
└── Сегменты
    └── Блоки (4КБ)
        └── Страницы (8КБ)
             ├── Живые tuple
             ├── Мёртвые tuple (дыры)
             └── Свободное место 
```

Когда “дыры” занимают 20–30% таблицы, чтение начинает замедляться.
Контроллеру приходится прыгать между блоками, а кэш буферов тратится на пустое пространство.

`VACUUM` на этом уровне просто перераспределяет внутренние указатели: “вот эти слоты теперь можно перезаписать”.
А `VACUUM FULL` физически презаписывает файл, и кладет данные последовательно на дорожки пластины  —
то есть устраняется сама **физическая фрагментация**.

---

## Автоматизация и эволюция

Со временем ручной VACUUM стал слишком трудоёмким — база могла просто раздуться, если администратор забывал его запустить.
Поэтому появился **autovacuum** — фоновый демон, который отслеживает количество мёртвых строк (`n_dead_tup`) и автоматически запускает чистку, если порог превышен.

Но даже autovacuum не всегда спасает: если нагрузка большая, "мёртвые" tuple накапливаются быстрее, чем autovacuum их успевает убирать.
Тогда администратор прибегает к “тяжёлой артиллерии” — `VACUUM FULL` или внешним инструментам вроде `pg_repack`, которые перестраивают таблицу без блокировки.

---

## Почему не просто “delete”?

Главное отличие VACUUM от обычного удаления в том, что он **работает с физикой данных**, а не с логикой.
`DELETE` лишь делает строки невидимыми для новых транзакций.
VACUUM же приходит позже и убирает их изнутри, освобождая реальные байты в страницах.

Это делает Postgres метафорически “самоочищающимся организмом”.

---

## Итог

`VACUUM` — вместо того чтобы перезаписывать всё заново, он не удаляет строки мгновенно, а ждёт, пока они действительно перестанут быть видимыми.
А потом  проходит по всем страницам и “откачивает" "мёртвые" данные.

Когда место становится слишком “дырявым”, включается тяжёлая очистка — `VACUUM FULL`,
и таблица, как жёсткий диск после дефрагментации, снова становится компактной и быстрой.

PostgreSQL не случайно выбрал это слово — **vacuum**:
он действительно словно создаёт внутри себя вакуум — очищая пространство.


## Связанные темы

- [HEAP файлы](./HEAP_Files.md)
- [TOAST файлы](./TOAST.md)
- [Размер блока данных и скорость чтения с диска](/DataManagement_and_Storage/Storage/Physical_layer/BlockSize_and_IO_Performance.md)