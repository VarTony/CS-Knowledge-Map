---
title: Алгоритм PGLZ в PostgreSQL
subtitle: Встроенный механизм сжатия данных в PostgreSQL
---

# Алгоритм PGLZ

`PGLZ` — это встроенный в PostgreSQL алгоритм сжатия общего назначения, используемый для уменьшения объёма данных переменной длины до того, как они будут вынесены в TOAST-хранилище.  
Его основная задача — **снизить количество I/O-операций** и **сохранить компактность heap-страниц** без привлечения внешних библиотек и сложных схем распаковки.

---

## Назначение и место в архитектуре

Механизм сжатия `PGLZ` активируется на этапе, когда строка после сборки tuple превышает внутренний порог `TOAST_TUPLE_TARGET` (около 2 КБ).  
Перед тем как вынести значение во внешнюю TOAST-таблицу, Postgres пытается **сжать его на месте**.  
Если результат помещается в текущую страницу и не превышает 2 КБ — значение сохраняется в сжатом виде.
Eсли нет — переносится в TOAST таблицу.

Таким образом:
- **varlena → PGLZ → TOAST** — последовательность этапов, через которые проходит большой атрибут.
- Сжатие прозрачно и не требует от клиента никакой логики распаковки — Postgres сам восстанавливает значение при чтении.

---

## Принцип работы

`pglz` основан на идее **LZ-подобного словаря**, но реализован максимально просто и безопасно для СУБД-ядра:

pglz не стремится найти идеальное совпадение — его цель — сжать достаточно хорошо и быстро, 
так как постгри это не професcионльный компресор данных.
При поиске повторяющихся фрагментов алгоритм действует по принципу локального оптимума:

Вот лаконичный фрагмент в твоём стиле — можно вставить в раздел «Механизм работы» конспекта по `pglz`:

---

### Механизм остановки поиска совпадений

`pglz` не стремится найти идеальное совпадение — его цель — сжать **достаточно хорошо и быстро**.
При поиске повторяющихся фрагментов алгоритм действует по принципу *локального оптимума*:

1. **Локальная выгода.** Если найден фрагмент длиной ≥ 3 байт, и прирост совпадения перестаёт расти — поиск завершается.
2. **Ограничение по глубине.** Проверяется только ограниченное число позиций в окне — порядка сотен, а не все 32 КБ.
3. **Ранний отсев.** Сравнение сразу прерывается, если первые байты не совпадают.
4. **Порог “достаточно хорошо”.** Найден матч приемлемой длины — алгоритм фиксирует результат и идёт дальше, не ища глобальный максимум.

Так `pglz` поддерживает **линейное время работы** и стабильную производительность, жертвуя несколькими процентами коэффициента ради предсказуемости и безопасности ядра PostgreSQL.

Остальные байты записываются как литералы (в неизменном виде).
Если итоговый размер меньше исходного — данные сохраняются в сжатом виде, иначе хранятся несжатыми.

Структура блока:
```text
+-----------+------------------+
| header    | compressed data  |
+-----------+------------------+
```

Заголовок (4 байта) содержит длину распакованных данных и флаг, что это формат `pglz`.

---

## Почему не zlib

PostgreSQL изначально ориентировался на независимость ядра и простоту обслуживания.
`pglz` — компактный, полностью встроенный алгоритм без внешних зависимостей.
Он работает предсказуемо, гарантирует отсутствие переполнений буфера и не требует динамического выделения памяти.
Главная цель — **безопасность и стабильность**, а не рекордный коэффициент сжатия.

---

## Характеристики

| Параметр             | Значение                                             |
| -------------------- | ---------------------------------------------------- |
| Алгоритм             | LZ-подобный (скользящее окно, длина ссылок до 32 КБ) |
| Максимальный выигрыш | До 50–60 % для текстов и JSON                        |
| Средняя скорость     | ~150–250 МБ/с (на современных CPU)                   |
| Используется в       | `text`, `jsonb`, `bytea`, `xml`, `array`, `hstore`   |
| Реализован в         | `src/common/pg_lzcompress.c`                         |

---

## Распаковка и прозрачность доступа

При чтении строки из heap-страницы Postgres определяет формат varlena по заголовку:
если установлен флаг `VARATT_COMPRESSED`, значение автоматически **распаковывается** функцией `pglz_decompress()` до исходного состояния.
Для пользователя это полностью прозрачно — SQL-уровень не знает, сжат ли атрибут или нет.

---

## Влияние на производительность

* **Поиск** — быстрее, за счёт уменьшенного объёма данных на странице.
* **Запись** — немного медленнее, из-за необходимости прохода по данным и построения словаря.
* **VACUUM** и **индексация** не требуют дополнительных операций: значение рассматривается как обычный varlena-объект.

Использование `pglz` особенно эффективно при хранении текстовых или JSON-полей средней длины (1–7 КБ), где включение TOAST нецелесообразно.

---

## Итог

`pglz` — это промежуточный слой между varlena и TOAST, делающий хранение больших значений в PostgreSQL **умным и экономным**.
Он не про глубокое сжатие, а про баланс: чуть больше CPU на запись, зато улучшение поиска и компактные heap-страницы.
Вместе с varlena и TOAST этот механизм формирует тройку, отвечающую за гибкость и устойчивость внутреннего формата PostgreSQL.

---

## Связанные темы

- [Varlena Format](./Varlena_Format.md)
- [TOAST: хранение больших атрибутов](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/TOAST.md)
- [HEAP-файлы](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/HEAP_Files.md)