---
title: Формат varlena в PostgreSQL
---

# Формат хранения varlena

Формат **varlena** (*variable-length attribute*) — это базовая структура, через которую PostgreSQL хранит данные переменной длины внутри heap-страниц.  
Любое поле, размер которого не фиксирован заранее (`TEXT`, `BYTEA`, `JSONB`, `ARRAY`, `XML` и др.), записывается в виде varlena-объекта.  
Эта структура образует основу механизма TOAST и позволяет Postgres работать с большими или сжатыми значениями без изменения физического формата строк.

---

## Общая идея

Каждое значение varlena состоит из двух частей:
1. **заголовок длины (varlena header)** — хранит информацию о размере и состоянии данных;
2. **тело (payload)** — собственно байты значения.

Размер заголовка варьируется — от 1 до 4 байт — в зависимости от того, насколько велико и как именно хранится значение.  
Тем самым PostgreSQL экономит место для коротких полей, не теряя универсальности формата.

---

## Варианты представления varlena

PostgreSQL использует четыре основных формата varlena, которые различаются по первому байту (флагу состояния):

| Формат | Назначение | Размер заголовка | Характеристика |
|--------|-------------|------------------|----------------|
| **4-byte header** | Стандартный формат | 4 байта | Обычное значение, длина хранится в первых 4 байтах |
| **1-byte header (short varlena)** | Короткие значения | 1 байт | Для данных ≤126 байт; применяется, чтобы избежать 4-байтного overhead’а |
| **TOAST pointer** | Ссылка на внешнее значение | 18 байт | Используется, когда данные вынесены во вспомогательную TOAST-таблицу |
| **Compressed varlena** | Сжатое значение | 4 байта | Те же поля, но часть данных хранится в сжатом виде (pglz) |

Фактический размер и интерпретация varlena определяются по **старшему биту первого байта** (0x80) и флагам внутри заголовка.

---

## Структура стандартного varlena

```text
+--------------------+------------------------------+
| 4 bytes header     | variable payload (n bytes)  |
+--------------------+------------------------------+
````

Заголовок (`int32`) содержит длину всего объекта, включая сам заголовок.
Таким образом, чтобы получить реальную длину полезных данных, движок просто вычитает 4 байта.

В памяти значение представляется как:

```c
struct varlena {
    int32  vl_len_;  // длина всего объекта
    char   vl_dat[FLEXIBLE_ARRAY_MEMBER]; // данные
};
```

---

## Короткий формат (short varlena)

Для коротких строк (<127 байт) Postgres использует “сжатый” формат с однобайтовым заголовком:

```text
+--------+-----------------------+
| 1 byte | up to 126 bytes data |
+--------+-----------------------+
```

Первый байт кодирует длину полезных данных (без себя).
Это позволяет избежать 3 лишних байт overhead’a при миллионах коротких строк — ощутимая экономия в OLTP-таблицах.

---

## Сжатый и внешнехранимый формат

Если значение превышает порог `TOAST_TUPLE_TARGET` (~2 KB):

1. Postgres пытается его **сжать** алгоритмом `pglz`;
2. если и после сжатия не помещается — значение превращается в **TOAST pointer**.

TOAST-указатель также хранится в varlena-обёртке, но вместо данных содержит:

* идентификатор TOAST-таблицы;
* OID строки в ней;
* смещение чанка и длину.

Таким образом, даже “вынесенные” значения формально продолжают оставаться varlena-объектами, обеспечивая единообразие доступа.

---

## Влияние на хранение и производительность

* Короткие varlena-значения оптимизируются автоматически — overhead минимален.
* Большие значения обрабатываются через TOAST, сохраняя общую структуру tuple.
* Любое varlena-поле может быть извлечено без десериализации всей строки: PostgreSQL хранит смещение каждого поля в tuple header.

Благодаря этому Postgres может эффективно работать как с короткими строками (`name`), так и с гигабайтными объектами (`bytea`), не ломая общую логику heap-страницы.

---

## Итог

`varlena` — это унифицированный контейнер для всех типов переменной длины.
Он решает задачу совместимости между heap, TOAST и компрессией, обеспечивая единый формат обращения.
Его гибкость стала одной из причин, почему PostgreSQL так легко адаптируется к произвольным типам данных — от обычных текстов до сложных JSON-структур.

---

## Связанные темы

- [TOAST: хранение больших атрибутов](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/TOAST.md)
- [HEAP-файлы](/DataManagement_and_Storage/DBMS/Implementations/PostgreSQL/Components/HEAP_Files.md)
- [PGLZ-Compression](./PGLZ_Compression.md)