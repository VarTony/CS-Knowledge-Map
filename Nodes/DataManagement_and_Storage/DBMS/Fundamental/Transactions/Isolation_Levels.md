---
title: Уровни изоляции транзакций
description: Как СУБД обеспечивает согласованность при одновременном выполнении запросов. Откуда берутся «грязные чтения», фантомы и блокировки.
tags:
  - dbms
  - transactions
  - concurrency
  - isolation_levels
  - mvcc
---

# Уровни изоляции транзакций

## Исторический контекст

В 70-х годах начали появляться первые СУБД (System R, Ingres, IMS), инженеры столкнулись с проблемой, которую тогда ещё не называли конкурентным доступом:  
несколько пользователей могли изменять одни и те же данные одновременно, и результаты оказывались непредсказуемыми.  

Решением стало введение **транзакций** — атомарных единиц работы с данными.  
Но оказалось, что просто атомарность не спасает от всех конфликтов.  
Нужно было чётко определить, **насколько изолированы** транзакции друг от друга.  
Так появились **уровни изоляции (isolation levels)** — баланс между скоростью и безопасностью данных.

---

## ACID и место изоляции

Транзакции определяются четырьмя свойствами — **ACID**:

1. **Atomicity** — атомарность: выполняется всё или ничего.  
2. **Consistency** — согласованность: база не нарушает инварианты(Больше про бизнес логику).  
3. **Isolation** — изоляция: транзакции не мешают друг другу.  
4. **Durability** — долговечность: результаты сохраняются даже после сбоя.

Изоляция — единственное свойство, которое не является абсолютным:  
её можно ослабить ради производительности.  
Отсюда и появление разных уровней.

---

## Что значит «изоляция»

Идеал — это **serializable**, когда все транзакции выполняются так, будто по очереди, хотя на деле параллельны.  
Но такое поведение дорого: блокировки, ожидания, рост задержек.

Поэтому стандарт SQL-92 ввёл четыре уровня изоляции:

| Уровень | Гарантирует | Может нарушаться |
|----------|--------------|------------------|
| **READ UNCOMMITTED** | ничего | грязное чтение, неповторяемое чтение, фантомы |
| **READ COMMITTED** | нет грязных чтений | неповторяемое чтение, фантомы |
| **REPEATABLE READ** | нет грязных и неповторяемых чтений | фантомы |
| **SERIALIZABLE** | поведение как при последовательном выполнении | ничего |

---

## Классические аномалии

Чтобы понять смысл уровней, нужно знать, от чего они защищают.

### 1. Грязное чтение (dirty read)
Транзакция читает данные, которые другая изменила, но ещё не зафиксировала.

```SQL
T1: UPDATE accounts SET balance = balance - 100 WHERE id = 1;
T2: SELECT balance FROM accounts WHERE id = 1; -- видит уже изменённое значение
T1: ROLLBACK;
```

`T2` прочитал то, чего фактически не существует.

---

### 2. Неповторяемое чтение (non-repeatable read)
При повторном чтении тех же данных результат меняется, потому что другая транзакция успела их изменить и зафиксировать.
```SQL
T1: SELECT balance FROM accounts WHERE id = 1; → 1000
T2: UPDATE accounts SET balance = 500 WHERE id = 1; COMMIT;
T1: SELECT balance FROM accounts WHERE id = 1; → 500
```

T1 дважды прочитала одну и ту же строку и получила разные результаты.

---

### 3. Фантомное чтение (phantom read)
Появляются или исчезают строки, удовлетворяющие условию.
```SQL
T1: SELECT * FROM orders WHERE price > 100; -- 5 строк
T2: INSERT INTO orders VALUES (999, 200); COMMIT;
T1: SELECT * FROM orders WHERE price > 100; -- 6 строк
```

Появился «фантом» — новая строка, которой не было при первом чтении.

---

## READ UNCOMMITTED

Самый слабый уровень изоляции.  
Транзакции видят **незакоммиченные изменения других**.  
Это быстро, но небезопасно — возможны все три аномалии.

Используется редко, в аналитических или временных таблицах, где точность не критична.

---

## READ COMMITTED

По умолчанию в большинстве СУБД (PostgreSQL, Oracle, MS SQL).  
Транзакция видит только **зафиксированные** данные.  
Каждый запрос получает снимок (snapshot) состояния на момент начала запроса,  
а не всей транзакции.

```SQL
T1: SELECT balance FROM accounts WHERE id = 1; → 1000
T2: UPDATE accounts SET balance = 500 WHERE id = 1; COMMIT;
T1: SELECT balance FROM accounts WHERE id = 1; → 500
```

Видно, что данные между запросами меняются — возможно неповторяемое чтение.

---

## REPEATABLE READ

Уровень, при котором СУБД создаёт **снимок данных на момент начала транзакции**.  
Все последующие чтения обращаются к тому же состоянию, даже если другие уже внесли изменения.  

```SQL
T1: START TRANSACTION;
T1: SELECT * FROM users WHERE id = 1; → name = 'Alice'
T2: UPDATE users SET name = 'Bob' WHERE id = 1; COMMIT;
T1: SELECT * FROM users WHERE id = 1; → name = 'Alice'
```

T1 видит прежние данные.  
Но если T2 добавит новую строку, удовлетворяющую условию выборки,  
T1 всё равно не заметит её — отсюда остаются фантомы.

---

## SERIALIZABLE

Самый строгий уровень.  
СУБД гарантирует, что результат будет эквивалентен последовательному исполнению.  
На практике реализуется двумя способами:

1. **Через блокировки (2PL — Two-Phase Locking)**  
   Все ресурсы блокируются до конца транзакции.  
   Безопасно, но может вызывать дедлоки.

2. **Через MVCC + проверку конфликтов**  
   Современные СУБД (PostgreSQL, Oracle) не блокируют читателей.  
   Они выполняют верификацию при коммите: если два параллельных изменения нарушают сериализацию, одна транзакция откатывается.

---

## MVCC — Многоверсионный контроль параллелизма

Большинство современных СУБД (PostgreSQL, Oracle, CockroachDB) используют **MVCC (Multiversion Concurrency Control)** — механизм, позволяющий разным транзакциям видеть разные версии строк без взаимных блокировок.

Каждая строка хранит два служебных поля:
``xmin — идентификатор транзакции, которая вставила запись
xmax — идентификатор, которая удалила (или обновила)

Читатели видят только те строки, где xmin ≤ их snapshot и xmax пуст.
Таким образом, чтения никогда не блокируют записи и наоборот.

### Сводка уровней изоляции
```
| Уровень              | Грязные чтения | Неповторяемые чтения | Фантомы  | Реализация               |
| -------------------- | -------------- | -------------------- | -------- | ------------------------ |
| **READ UNCOMMITTED** | возможны       | возможны             | возможны | без блокировок           |
| **READ COMMITTED**   | нет            | возможны             | возможны | snapshot per query       |
| **REPEATABLE READ**  | нет            | нет                  | возможны | snapshot per transaction |
| **SERIALIZABLE**     | нет            | нет                  | нет      | 2PL или MVCC-конфликт    |
```


### Практика и нюансы
PostgreSQL:
использует MVCC, где REPEATABLE READ фактически эквивалентен сериализуемому поведению по снимкам (Serializable Snapshot Isolation).
MySQL/InnoDB:
в режиме REPEATABLE READ предотвращает фантомы за счёт блокировок диапазонов (gap locks).
Oracle:
реализует только READ COMMITTED и SERIALIZABLE, где сериализация достигается логической проверкой конфликтов.


### Реалистичный пример выбора:

| Сценарий                               | Рекомендуемый уровень | Обоснование                               |
| -------------------------------------- | --------------------- | ----------------------------------------- |
| Онлайн-система (CRM, веб-приложение)   | **READ COMMITTED**    | компромисс между целостностью и скоростью |
| Финансовые операции, баланс, пересчёты | **SERIALIZABLE**      | гарантия корректности                     |
| Аналитика, отчёты без блокировок       | **REPEATABLE READ**   | стабильность снимка                       |
| Черновые или временные расчёты         | **READ UNCOMMITTED**  | максимальная скорость                     |

Итог
Уровни изоляции — это не просто опции SQL, а инструмент управления компромиссом между производительностью и логической целостностью.
Чем выше уровень, тем меньше аномалий, но тем больше блокировок и ожиданий.

```
READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE
      ↑ скорость                                   ↑ надёжность
```

В идеале все работали бы на SERIALIZABLE,
но реальный мир требует баланса: скорость важна не меньше, чем чистота данных.
И именно этот баланс определяет, насколько «живо» работает база под нагрузкой.

## Связанные темы