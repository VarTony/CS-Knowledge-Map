---

title: Аномалии параллельного доступа при уровнях изоляции
description: Какие логические ошибки возникают при одновременном выполнении транзакций, почему SQL стандартизировал уровни изоляции и как различные СУБД устраняют эти аномалии.

---

# Проблематика

Многопользовательские СУБД 1970-х годов (System R, Ingres) столкнулись с проблемой, которая возникла не из теории, а из реального использования:
**одновременные транзакции начинали вмешиваться в данные друг друга.**

Возникли ситуации, когда одна транзакция читала “будущие” данные, другая — перезаписывала изменения соседа, а третья видела строки, которых «ещё нет» или которых «уже нет» — эффект *фантомов*.

Эти явления стали называть **аномалиями параллелизма (concurrency anomalies)**.
Чтобы формализовать и классифицировать их, в стандарт SQL-92 были введены **уровни изоляции транзакций**.

Именно аномалии определили необходимость уровней изоляции, а не наоборот.

---

# 1. Грязное чтение (Dirty Read)

### Суть

Транзакция читает изменения, сделанные другой транзакцией, **которая ещё не зафиксирована (не завершена)**.

Если вторая транзакция сделает откат, первая будет опираться на данные, которых никогда не существовало.

### SQL-сценарий

```sql
-- Транзакция T1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Транзакция T2
SELECT balance FROM accounts WHERE id = 1; -- видит уже уменьшенный баланс

-- T1
ROLLBACK; -- изменения отменены, но T2 увидела "призрак" операции
```

### На каких уровнях возможно

| Уровень          | Грязное чтение |
| ---------------- | -------------- |
| READ UNCOMMITTED | возможно       |
| READ COMMITTED   | ✖ запрещено    |
| REPEATABLE READ  | ✖ запрещено    |
| SERIALIZABLE     | ✖ запрещено    |

### ⚙ Как устраняется

* **MVCC**: незакоммиченные версии строк (*xmax=xid активной транзакции*) не видны другим.
* **Locking (старые СУБД)**: чтение блокируется до коммита.

---

# 2. Неповторяемое чтение (Non-Repeatable Read)

### Суть

Транзакция дважды читает одну и ту же строку, и между чтениями другая транзакция её изменила и зафиксировала. В результате одно и то же выражение возвращает **разные данные**.

### SQL-сценарий

```sql
-- T1
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 1000

-- T2
UPDATE accounts SET balance = 500 WHERE id = 1;
COMMIT;

-- T1
SELECT balance FROM accounts WHERE id = 1; -- уже 500
```

### Уровни

| Уровень          | Неповторяемое чтение |
| ---------------- | -------------------- |
| READ UNCOMMITTED | возможно             |
| READ COMMITTED   | возможно             |
| REPEATABLE READ  | ✖ запрещено          |
| SERIALIZABLE     | ✖ запрещено          |

### Как устраняется

* **MVCC snapshot**: транзакция видит те версии строк, которые существовали **в момент её начала**.
* **Locking (MySQL InnoDB)**: блокировка строки до окончания транзакции.

---

# 3. Фантомное чтение (Phantom Read)

### Суть

Транзакция повторяет запрос с условием (например, WHERE price > 100), и во второй раз видит **новые строки**, которые были добавлены другой транзакцией и удовлетворяют условию.

### SQL-сценарий

```sql
-- T1
BEGIN;
SELECT * FROM orders WHERE price > 100; -- 5 строк

-- T2
INSERT INTO orders VALUES (999, 200);
COMMIT;

-- T1
SELECT * FROM orders WHERE price > 100; -- уже 6 строк
```

### Уровни

| Уровень          | Фантомы                 |
| ---------------- | ----------------------- |
| READ UNCOMMITTED | возможно                |
| READ COMMITTED   | возможно                |
| REPEATABLE READ  | возможно (по стандарту) |
| SERIALIZABLE     | ✖ запрещено             |

⚠ *Важно:* PostgreSQL предотвращает фантомы уже на уровне REPEATABLE READ, используя MVCC snapshot isolation.

### ⚙ Как устраняется

* **2PL (Two-phase locking)**: блокировка диапазона (range lock).
* **MVCC + сериализация при фиксации (SSI)**: запрет транзакций, создающих логический конфликт.

---

# 4. Потерянное обновление (Lost Update)

### Суть

Две транзакции читают одну и ту же строку и обновляют её, основываясь на устаревшем значении, перезаписывая изменения друг друга.

### SQL-сценарий

```sql
-- T1
SELECT balance FROM accounts WHERE id = 1; -- 1000

-- T2
SELECT balance FROM accounts WHERE id = 1; -- 1000

-- T1
UPDATE accounts SET balance = 900 WHERE id = 1; -- -100
COMMIT;

-- T2
UPDATE accounts SET balance = 950 WHERE id = 1; -- -50, теряет -100 транзакции T1
COMMIT;
```

### Уровни

| Уровень          | Lost Update |
| ---------------- | ----------- |
| READ UNCOMMITTED | возможно    |
| READ COMMITTED   | возможно    |
| REPEATABLE READ  | ✖ запрещено |
| SERIALIZABLE     | ✖ запрещено |

### ⚙ Как устраняется

* Блокировки при `UPDATE ... WHERE`
* В PostgreSQL: через MVCC + проверку актуальности версии строки (ctid меняется)

---

# 5. Write Skew (аномалия смещения записи)

### Суть

Две транзакции читают одни и те же данные, делают разные изменения, и обе коммитят, нарушая бизнес-ограничение, которое каждая по отдельности не нарушает.

### SQL-сценарий (дежурные врачи)

```
Есть правило: в смене должен быть хотя бы один врач.
T1: SELECT COUNT(*) FROM doctors_on_duty WHERE shift_id = 1; -- 1 врач
T2: SELECT COUNT(*) FROM doctors_on_duty WHERE shift_id = 1; -- 1 врач

T1: UPDATE doctors SET on_duty = false WHERE id = 1; COMMIT;
T2: UPDATE doctors SET on_duty = false WHERE id = 2; COMMIT;

Результат: 0 врачей, правило нарушено.
```

### Уровни

| Уровень         | Write Skew  |
| --------------- | ----------- |
| REPEATABLE READ | возможно    |
| SERIALIZABLE    | ✖ запрещено |

### ⚙ Как устраняется

* **Serializable Snapshot Isolation (SSI)**: проверка конфликтов при коммите, и откат одной из транзакций.

---

# 6. Аномалия чтения несогласованного состояния (Read Skew)

Транзакция читает данные, находящиеся в промежуточной логической стадии. Например, одно поле уже обновлено, а связанное с ним — ещё нет.

### Решение

Только SERIALIZABLE гарантирует целостность набора данных как единого логического состояния.

---

# Таблица соответствия аномалий уровням изоляции

| Аномалия              | RU | RC | RR | SER |
| --------------------- | -- | -- | -- | --- |
| Грязное чтение        | ✔  | ✖  | ✖  | ✖   |
| Неповторяемое чтение  | ✔  | ✔  | ✖  | ✖   |
| Фантомы               | ✔  | ✔  | ✔* | ✖   |
| Потерянное обновление | ✔  | ✔  | ✖  | ✖   |
| Write Skew            | ✔  | ✔  | ✔  | ✖   |

* в PostgreSQL REPEATABLE READ предотвращает фантомы с помощью MVCC.

---


# Группировка аномалий по их общей природе

Аномалии конкурентного доступа можно разделить не только по уровням изоляции, но и **по их природе**.
Все они возникают из-за несогласованного доступа к данным, но проявляются по-разному в зависимости от того, *какая операция выполняется*: чтение или запись.

```
| Группа                 | Аномалии                                       | Общая природа                                                                                                                                                                      |
| ---------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Аномалии чтения**    | Dirty Read, Non-Repeatable Read, Phantom Read  | Транзакция читает данные, которые ещё не зафиксированы или могут измениться другой транзакцией в процессе выполнения. Проблема заключается в **видимости неверной версии данных**. |
| **Аномалии записи**    | Lost Update, Write Skew, Serialization Anomaly | Две транзакции одновременно изменяют связанные данные, нарушая бизнес-правило или перезаписывая результат друг друга. Общая суть — **конфликт записи и нарушение инварианта**.     |
| **Смешанные аномалии** | Read Skew                                      | Транзакция читает набор данных, находящийся в логически неполном состоянии, что приводит к неправильным выводам при последующей записи.                                            |
```

**Таким образом:**

* *Dirty Read* и *Lost Update* относятся к одной фундаментальной категории — **нарушение согласованности версий данных**, просто в первом случае ошибка проявляется при чтении, а во втором — при записи.
* *Write Skew* и *Phantom Read* — проявление одной проблемы на уровне набора данных: система видит *частичный или неполный срез* и принимает решение на основе данных, которые были корректны на момент чтения, но перестали быть таковыми к моменту записи.

Эта группировка важна, потому что **указание уровня изоляции недостаточно**. Необходимо понимать, какую **категорию риска** устраняет тот или иной механизм:
**устранение неверного чтения (read consistency)** или **устранение конфликтов записи (write integrity)**.


# Итог

* Аномалии — это не теоретические концепты, а реальные ошибки, приводящие к потере данных, нарушению инвариантов и финансовым убыткам.
* Уровни изоляции были введены *именно как ответ на эти явления*.
* **Главная цель изоляции — не "ускорение работы", а "сохранение смысла данных" при параллельных изменениях.**
* Современные СУБД используют **MVCC, блокировки и проверку конфликтов при коммите**, чтобы устранить аномалии не ценой производительности, а ценой *умной многоверсионности*.

---

## Связанные темы

- [Уровни изоляции транзакций](./Isolation_Levels.md)
- [Версионная реализация MVCC](./Vercions.md) TODO
- [ACID](./ACID.md)