---
title: Буфер-менеджер
description: Как работает буфер-менеджер — компонент, связывающий оперативную память и дисковое хранилище.
tags:
  - dbms
  - storage_engine
  - buffer_manager
  - caching
  - page_replacement
---

# Буфер-менеджер

## Исторический контекст

Первые системы управления базами данных работали напрямую с дисками.  
Каждый запрос открывал файл, читал блоки, писал обратно — и всё это происходило медленно.  
Когда в 70-х годах IBM разрабатывала System R, а позже — Oracle и Ingres, инженеры поняли:  
всё упирается не в алгоритмы, а в скорость дискового ввода-вывода.

Решением стала идея **буфера страниц** — промежуточного слоя между оперативной памятью и диском.  
Этот слой стал называться **буфер-менеджером** (buffer manager).  
С тех пор он стал неотъемлемой частью всех СУБД — от PostgreSQL до InnoDB.

---

## Что такое буфер-менеджер

Буфер-менеджер — это компонент СУБД, который управляет областью оперативной памяти,  
используемой для временного хранения страниц данных, загруженных с диска.  
```
Диск ←→ Буфер-менеджер ←→ Остальные компоненты СУБД (планировщик, исполнители запросов)
```

Его основная цель — минимизировать физические обращения к диску.  
Он делает это с помощью:
1. **буферного пула (buffer pool)** — области RAM, разбитой на страницы;
2. **таблицы отображения (buffer table)** — чтобы знать, какая страница из базы сейчас находится в памяти;
3. **механизма вытеснения (replacement policy)** — чтобы освободить место при необходимости;
4. **контроля “грязных” страниц (dirty pages)** — чтобы изменённые данные не потерялись при выгрузке.

---

## Структура буферного менеджера
```
┌───────────────────────────────────────────────────────────────┐
│ Буферный пул (Buffer Pool) — множество фреймов (8 КБ каждый)  │
│---------------------------------------------------------------│
│ Таблица страниц (Buffer Table) — хеш-таблица: page_id → frame │
│---------------------------------------------------------------│
│ Списки LRU / Clock — алгоритм замещения страниц               │
│---------------------------------------------------------------│
│ Списки Dirty Pages — страницы, требующие записи на диск       │
└───────────────────────────────────────────────────────────────┘
```


Каждый фрейм в буфере имеет служебный заголовок:

| Поле | Значение |
|------|-----------|
| page_id | логический номер страницы в файле |
| pin_count | количество активных обращений |
| is_dirty | была ли страница изменена |
| usage_count / LRU position | для алгоритма замещения |

---

## Как это работает

### 1. Запрос страницы

Когда планировщик или исполнитель запроса хочет получить страницу с данными,  
он обращается к буфер-менеджеру функцией вроде:

``BufferManager::fetchPage(page_id)``

Буфер-менеджер проверяет свою таблицу:
- если страница уже в буфере — возвращает указатель (hit);
- если нет (miss) — выбирает свободный или вытесняемый фрейм.

### 2. Вытеснение и запись на диск

Если выбранный фрейм содержит изменённые данные (`is_dirty=true`),  
он записывается обратно на диск перед перезаписью.  
После этого новая страница считывается с диска в тот же фрейм.

### 3. Фиксация и освобождение

Когда верхние уровни (executor, index manager) заканчивают работу со страницей,  
они вызывают ``unpin(page_id)``.  
Если `pin_count` падает до нуля, страница становится кандидатом на вытеснение.

---

## Алгоритмы замещения страниц

Буфер ограничен, поэтому нужно решать, какую страницу выгружать при нехватке места.  
Эта задача аналогична кешированию, и здесь работают классические политики:

| Политика | Принцип | Комментарий |
|-----------|----------|-------------|
| **LRU (Least Recently Used)** | выгружается страница, к которой давно не обращались | прост, но требует поддержки порядка |
| **Clock / 2Q** | страница получает второй шанс перед удалением | баланс между скоростью и точностью |
| **MRU** | вытесняется недавно использованная | полезно при последовательных чтениях |
| **ARC / LIRS** | адаптивные алгоритмы, учитывающие локальность доступа | применяются в Oracle, MSSQL |

В PostgreSQL используется **Clock-sweep** — модификация алгоритма Clock с плавным уменьшением счётчика активности.

---

## Грязные страницы и журналирование

Когда страница изменяется, она помечается как ``dirty``.  
Буфер-менеджер не пишет её на диск сразу, чтобы избежать лишних I/O.  
Сначала запись фиксируется в **журнале WAL (Write-Ahead Log)**,  
а потом — периодически или при вытеснении — страница сбрасывается на диск.

Это обеспечивает **атомарность**:  
даже если СУБД внезапно завершится, WAL позволит восстановить изменения при следующем запуске.

---

## Связь с виртуальной памятью

Буфер-менеджер — это, по сути, «внутренний MMU СУБД».  
Он подменяет логические адреса страниц базы на физические адреса в буфере,  
точно так же, как ОС отображает виртуальные адреса в RAM.
```Логическая страница (page_id) → Фрейм в памяти → Смещение на диске```

Разница в том, что СУБД делает это **"осознанно"** —  
она знает, какие страницы часто используются, какие можно сбросить,  
и может управлять приоритетами доступа.

---

## Параллелизм и фиксации

В многопользовательской среде один и тот же блок данных может быть открыт несколькими транзакциями.  
Буфер-менеджер решает, кто имеет право его читать и кто — изменять.  
Для этого у каждой страницы есть:

- **pin count** — сколько клиентов её удерживают;  
- **lock** — режим доступа (shared / exclusive);  
- **dirty flag** — нужно ли записывать при вытеснении.

Пока `pin_count > 0`, страница не может быть выгружена.

---

## Управление памятью внутри буфера

Буфер-пул обычно разбивается на под-пулы (subpools) или группы:

| Пул | Назначение |
|------|-------------|
| **Default** | общие данные таблиц |
| **Free List** | свободные фреймы |
| **Dirty List** | изменённые страницы |
| **Pinned** | страницы, удерживаемые активными транзакциями |
| **Temp / Work Mem** | временные буферы для сортировок и join-операций |

Эти структуры управляются асинхронными процессами (background writer, checkpoint),  
которые регулярно записывают dirty-страницы, чтобы не создавать «лавину» при сбросе.

---

## Виды буферов

1. **Shared buffer pool** — общий для всех соединений.  
   Именно его размер задаётся параметром `shared_buffers` (в PostgreSQL).  
2. **Private buffers** — временные буферы внутри сессий, например для сортировок (`work_mem`).
3. **OS cache** — файловая система тоже кэширует страницы,  
   но база может частично обходить его с помощью `O_DIRECT`.

Так формируется **двойная буферизация**:  
один кэш в ядре ОС, другой — внутри самой СУБД.  
Современные движки стараются избегать дублирования, напрямую работая с диском.

---

## Пример жизненного цикла страницы
```
 1. Клиент выполняет SELECT → нужен page #42.
 2. Buffer Manager проверяет hash(page_id=42) — страницы нет.
 3. Выбирается victim (например, page #13), если dirty → flush.
 4. С диска читается page #42 в свободный frame.
 5. page_id=42 добавляется в buffer table.
 6. pin_count++ → страница закреплена.
 7. Executor читает данные, потом unpin().
 8. При следующем обращении — hit в памяти.
```

---

## Почему это важно

Буфер-менеджер — точка, где решается **производительность всей СУБД**.  
От его работы зависит:
- сколько физических чтений происходит;
- как часто база обращается к диску;
- насколько равномерно распределены страницы;
- и даже эффективность параллельных запросов.

Плохо настроенный буфер превращает мощную СУБД в дискозависимое чудовище,  
где каждый join вызывает каскад I/O-операций.

---

## Итог

Буфер-менеджер — это сердце подсистемы хранения базы данных.  
Он объединяет идеи виртуальной памяти, кеширования и журналирования.  
Его главная задача — сделать так, чтобы логические страницы казались всегда «рядом»,  
даже если физически они на диске в километрах друг от друга.

Через него проходят все операции чтения и записи,  
а его решения определяют баланс между скоростью и надёжностью.  

В современной СУБД именно буфер-менеджер превращает медленный диск в “почти оперативную память”.

---

## Смежные темы

- [Предварительная подгрузка и буферизация данных при работе с дисками](../../../Storage/Physical_layer/Prefetching_and_Buffering.md)
- [Fault Tolerance — WAL и атомарность страниц](../FaultTolerance/WAL_and_Page_Atomicity.md)
