---
title: Undo, Redo и Undo/Redo
---

# Исторический смысл и происхождение названий

| Термин        | Что означает дословно     | Интуитивный смысл                                          |
| ------------- | ------------------------- | ---------------------------------------------------------- |
| **Undo**      | *отменить сделанное*      | Вернуть данные к старому значению                          |
| **Redo**      | *повторить снова*         | Применить новое значение ещё раз                           |
| **Undo/Redo** | *и отменить, и повторить* | Убрать незавершённые транзакции и восстановить завершённые |

**Контекст:**
Реляционо подобные СУБД активно работают с дисками и буферизацией. Данные сначала попадают в оперативную память (буфер), и только потом — на диск. Если в этот момент питание отключается, часть данных может быть в памяти. Тогда возникает вопрос:

> *Как понять, что было уже записано на диск, что осталось только в памяти, и как восстановить согласованность базы данных?*

Для этого придумали **журнал (лог)** — последовательность записей о действиях транзакций.

WAL-принцип (*Write-Ahead Logging*):
**"Сначала записываем, что собираемся изменить (в журнал), и только потом изменяем данные."**

---

# Операции ввода-вывода (как всё двигается)

| Действие     | Операция                                                      | Где выполняется |
| ------------ | ------------------------------------------------------------- | --------------- |
| `INPUT(X)`   | Загрузка элемента X с диска в буфер                           |                 |
| `READ(X,t)`  | Читаем X в локальную переменную t                             |                 |
| `WRITE(X,t)` | Меняем значение X в буфере                                    |                 |
| `OUTPUT(X)`  | Выгружаем буфер X с изменением обратно на диск                |                 |
| `FLUSH LOG`  | Записываем журнал на диск (гарантируем, что запись сохранена) |                 |

---

# Режим **UNDO** (откат)

**Идея:**
*Перед тем как изменить данные на диске, сохрани **старое значение** в журнал. Если транзакция не завершилась — откатить.*

### Поток работы (упрощённый пример)

```text
READ(X=100)
WRITE(X=200)
LOG: <T, X, 100>       ← записали старое значение (undo-запись)
OUTPUT(X)             ← изменённое значение ушло на диск
COMMIT                ← фиксируем завершение
```

### Если произошёл сбой **до COMMIT**

* На диске X = 200, но транзакция не завершена
* Журнал содержит `<T, X, 100>`
* **UNDO делает откат:** X возвращается к 100

Запуск `OUTPUT(X)` выполняется **до** commit, поэтому требуется хранить старое значение, чтобы была возможность отката.

---

# Режим **REDO** (повтор)

**Идея:**
*Сначала записываем новое значение в журнал, а уже потом пишем на диск. Если сбой — просто повторить (redo) коммитнутые изменения.*

### Поток работы

```text
READ(X=100)
WRITE(X=200)
LOG: <T, X, 200>      ← записали новое значение (redo-запись)
COMMIT                ← запись <COMMIT> в журнал
OUTPUT(X)             ← данные позже попадают на диск
```

### Если произошёл сбой **после COMMIT, но до OUTPUT**

* На диске X = 100 (старое значение)
* В журнале X=200 и COMMIT уже записан
* **REDO повторяет операцию** → X=200 снова применится к диску

Здесь `OUTPUT(X)` может быть отложен → поэтому нужно хранить **новое значение**.

---

# Гибридный режим **UNDO/REDO** (современный стандарт)

**Идея:**
*Храним и старое, и новое значение. Тогда можно и откатить незавершённые транзакции, и докатить завершённые.*

### Поток работы

```text
INPUT(X)              ← менеджер буферов загружает блок X с диска в буфер
READ(X, t)            ← транзакция копирует значение X в локальную переменную t (t = 100)
t = 200               ← локальное вычисление нового значения (например, t = t + 100)
WRITE(X, t)           ← менеджер буферов записывает новое значение 200 в буфер (данные ещё не на диске)

LOG: <T, X, old=100, new=200>   ← запись старого и нового значения в журнал
FLUSH LOG              ← журнал сбрасывается на диск (WAL гарантирован)

-- на этом этапе X в буфере, но на диске ещё старое значение

OUTPUT(X) (может быть позже)   ← изменённая страница может быть сброшена на диск автоматически или по требованию

COMMIT               ← запись <COMMIT T> в журнал → тоже проходит через FLUSH LOG
```

### Если сбой:

| Случай                                 | Действие системы             |
| -------------------------------------- | ---------------------------- |
| Транзакция **не успела закоммититься** | выполняется **UNDO** → X=100 |
| Транзакция **успела закоммититься**    | выполняется **REDO** → X=200 |

Преимущество: **любая ситуация покрыта**.

---

# Сводная таблица

| Режим     | Что хранится в журнале           | Когда пишем данные на диск       | Как восстанавливаем  |
| --------- | -------------------------------- | -------------------------------- | -------------------- |
| UNDO      | Старое значение (до изменения)   | До COMMIT (ранний OUTPUT)        | Откатываем изменения |
| REDO      | Новое значение (после изменения) | После COMMIT (отложенный OUTPUT) | Повторяем изменения  |
| UNDO/REDO | Старое и новое значение          | Гибко (или до, или после)        | Откат + повтор       |

---

# Главное, что нужно запомнить

1. **UNDO = вернуться назад** (откатить незавершённое)
2. **REDO = повторить вперёд** (записать на диск завершённое)
3. **UNDO/REDO = всё вместе** → используется в PostgreSQL, Oracle, MySQL InnoDB

---

# Связанные темы

- [Буферный менеджер](/Nodes/DataManagement_and_Storage/DBMS/Fundamental/Components/Buffer_Manager.md)
- [WAL концепт](./WAL_Concept.md)