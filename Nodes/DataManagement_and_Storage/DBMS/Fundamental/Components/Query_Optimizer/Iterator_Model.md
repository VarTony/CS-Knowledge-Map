---
title: Модель итератора — Volcano-style execution
subtitle: Архитектура потокового выполнения запросов и её связь с материализацией
---

# Модель итератора (Volcano-style execution)

 В 1990-х годах исследовательская система **Volcano** предложила новый способ исполнения запросов, это стало поворотным моментом в развитии архитектуры СУБД.  
До этого каждая стадия запроса выполнялась полностью и сохраняла свой результат — материализуя промежуточные таблицы на диск. Это выглядело естественно, но каждый оператор ожидал завершения предыдущего, превращая выполнение в цепочку ожиданий.

Volcano принесла противоположную идею — **итерационную, потоковую модель**, где данные не материализуются, а передаются по одному кортежу за раз, снизу вверх, через цепочку операторов.  
Так родилась модель итератора, на которой и сегодня построено большинство промышленных СУБД, включая PostgreSQL.

---

## До Volcano: материализация как базовая стратегия

Первые оптимизаторы и движки реляционных баз мыслили просто:  
каждый оператор (JOIN, SORT, FILTER) строит **весь результат целиком**, складывает его в память или на диск, а следующий оператор уже читает его как готовую таблицу.  
Такой подход назывался **моделью материализации**.

Он был интуитивно понятен, но имел очевидные издержки:

* промежуточные результаты могли занимать гигабайты;
* каждый шаг блокировал следующий;
* первые строки запроса появлялись только после полной обработки предыдущего этапа.

---

## Идея Volcano и появление итератора

Volcano предложила другой путь — **построчную обработку**, где каждый оператор работает как генератор, возвращающий по одной записи за вызов.

Вместо того чтобы “считать всё”, система начинает “тянуть” данные сверху:  
корневой оператор (`SELECT`) вызывает `GetNext()`, тот обращается к нижестоящему оператору, и цепочка уходит вниз к источнику данных.  
Каждый возвращает по одной строке вверх по стеку вызовов.

Такой стиль получил имя **Volcano-style execution** — в честь проекта, впервые оформившего эту архитектуру как модульный движок исполнения.

---

## Интерфейс оператора

Каждый узел плана реализует три базовых метода:

```text
Open()
GetNext()
Close()
````

* **Open()** — инициализация: выделение буферов, открытие курсоров, подготовка индексов;
* **GetNext()** — возврат следующего кортежа;
* **Close()** — освобождение ресурсов.

Цепочка этих вызовов формирует **поток данных**, где результат одного узла становится входом другого.
Движение данных направлено **снизу вверх**, а управление вызовами — **сверху вниз**.

---

## Пример

```sql
SELECT customers.name, orders.id, orders.amount
    FROM customers
    JOIN orders ON orders.customer_id = customers.id
    WHERE orders.amount > 100;
```

---

## Вариант 1 — когда индекс есть

План выполнения:

```
Nested Loop Join
│
├── Seq Scan on customers
└── Index Lookup on orders (customer_id)
```

1. **`customers.GetNext()`** — возвращает первую запись `(id=1, name='Anna')`.
   Таблица читается последовательно, страница за страницей.

2. **`orders.GetNext(customer_id=1)`** — обращается к индексной структуре.

   * Индекс быстро находит позиции всех заказов `customer_id=1`.
   * Система выбирает только те, где `amount > 100`.
   * Каждый найденный заказ возвращается вверх в `Join`.

3. `Join` комбинирует `(Anna)` и `(например: Order#11, 250)` и немедленно отдаёт результат вверх по конвейеру.
    После завершения всех заказов Анны `Join` запрашивает следующего клиента.

Физически всё это выглядит так:

```
[Page: customers] → record (id=1)
  └─→ [Index Page: orders.customer_id]
         └─→ [Page: orders] → record (id=11, amount=250) <- пример найденого кортежа
```

→ Итерации происходят поштучно, I/O минимален, потому что индекс позволяет точечно извлекать нужные страницы заказов.

---

## Вариант 2 — когда индекса нет

План выполнения меняется:

```
Hash Join
│
├── Seq Scan on customers
└── Seq Scan on orders
```

1. **`orders.GetNext()`** — во время инициализации (`Open()`) оператор `Hash Join` читает всю таблицу `orders` **один раз** и строит в памяти хеш-таблицу по `customer_id`.
   Это локальная материализация (в пределах одного оператора).

2. **`customers.GetNext()`** — возвращает строку `(id=1, name='Anna')`.
   Для неё `Hash Join` выполняет быстрый поиск в уже готовом хеше.
   Все подходящие записи `(например: Order#11, 250)` немедленно выдаются вверх.

Физически:

```
[Seq Scan: orders] → HashTable(in-memory)
[Seq Scan: customers] → record (id=1)
     └─→ Hash lookup → match → emit()
```

→ Здесь больше CPU и памяти, но меньше дисковых обращений, чем в Nested Loop без индекса.

---

## Сравнение стратегий

| Характеристика  | С индексом            | Без индекса                       |
| --------------- | --------------------- | --------------------------------- |
| Тип Join        | Nested Loop           | Hash Join                         |
| Доступ к данным | Точечный (random I/O) | Последовательный (sequential I/O) |
| Материализация  | Нет                   | Частичная (в хеше)                |
| Буферизация     | Низкая                | Средняя                           |
| Начало вывода   | Почти мгновенно       | После построения хеша             |

---

## Оппозиция: материализация

Модель материализации остаётся важной альтернативой — она применяется, когда итераторная схема неэффективна или невозможна.
Типичные случаи:

* **Сортировка и агрегации.** Оператору нужно видеть весь набор, прежде чем начать отдавать результат.
* **Хеш-соединения.** Строится полная хеш-таблица перед первой строкой вывода.
* **Переиспользуемые подзапросы.** Если одна и та же часть плана нужна в нескольких местах, её выгоднее материализовать один раз.
* **Параллельное исполнение.** Для синхронизации потоков данные могут временно буферизоваться.

В таких местах поток разрывается, и результат сохраняется — временно или полностью.

---

## Курсор: поверхностный аналог итератора

На уровне SQL разработчик видит ту же идею через **курсоры**.
`DECLARE CURSOR` создаёт внешний объект, который позволяет забирать результат **построчно**, командой `FETCH NEXT`.

Но важно понимать — **курсоры и итераторы находятся на разных уровнях абстракции**:

| Уровень                     | Механизм           | Что делает                                  |
| --------------------------- | ------------------ | ------------------------------------------- |
| **Внутренний (ядро)**       | Итератор (Volcano) | Передаёт кортежи между узлами плана         |
| **Внешний (SQL-интерфейс)** | Курсор             | Позволяет клиенту получать строки порционно |

Курсор не включает особый режим исполнения — он просто “подключается” к уже существующему итератору на вершине плана и вытягивает строки наружу.
Для ядра это обычный вызов `GetNext()`, только инициированный не внутренним узлом, а клиентом.

---

## Архитектурная ценность

Модель итератора позволила реляционным системам стать **настоящими потоковыми вычислителями**, где каждая операция — узел в графе, а результат может начинать возвращаться задолго до завершения запроса.

Её преимущества:

* **Стриминг и малая латентность** — первые строки появляются мгновенно.
* **Экономия памяти** — нет нужды хранить весь результат между стадиями.
* **Гибкость оптимизатора** — любой узел может быть заменён, перестроен или материализован отдельно.
* **Единый интерфейс** — любой оператор можно вызвать одинаково: `Open → GetNext → Close`.

---

## Итог

Volcano-style execution стала основой исполнения SQL-запросов:
она соединяет операторы в единый конвейер, где данные поднимаются снизу вверх, а управление движется сверху вниз.
Материализация осталась рядом — как вспомогательный инструмент, когда поток нужно прервать.
А курсоры — лишь внешняя тень этого механизма, позволяющая пользователю работать с тем же конвейером на своём уровне.

---

## Связанные темы

- [Оптимизация планов запросов](./Query_Plans_Optimization.md)
- [Материализация](./Materialization_Model.md) // TODO
- [Cursors in SQL](../../Interfaces/Cursors.md) // TODO
