---
title: Merge Join
---


# Смысловая модель

Представим две отсортированные последовательности. Мы хотим найти элементы, совпадающие по ключу. Логика проста:

* если текущее значение в первой последовательности меньше — продвигаемся в ней вперёд;
* если больше — двигаемся во второй;
* если равны — фиксируем совпадение и идём дальше.

Этот внутренний алгоритм еще называют "zig-zag join".

---

# Алгоритм "zig-zag join"

Если входные отношения **не отсортированы**, СУБД выполнит сортировку заранее (часто с использованием внешней сортировки). Если уже есть подходящий индекс — можно сразу переходить к сканированию.

Пример "zig-zag join":

```
Sort R by join key   (если не отсортировано)
Sort S by join key   (если не отсортировано)s

r = first(R)
s = first(S)

while r and s:
    if r.key < s.key:
        r = next(R)
    elif r.key > s.key:
        s = next(S)
    else:
        output join(r, s)
        r = next(R)
        s = next(S)
```

При совпадении ключей возвращаются пары строк. Если ключ встречается диапазоном, СУБД обрабатывает диапазоны целиком, не теряя текущую позицию.
Оптимизатор может выбрать эту стратегию соединения, если при соединение испльзуется строкое равенство и на ключевой атрибут уже навешен индекс или по нему вызывается сортировка в самом запросе. Если же слияние производится не по строгому равенству, а например в диапозонных предикатах, То merge-join не будет использован, единственное исключение поставить, если запрос таковое позволяет, рядом с предикатом использующим >/<, условие со строгим равенством, в таком случае гипотетически оптимизатор может выбрать merge вместо nested.

# Свойства и преимущества

### Когда merge join оптимален

| Условие                          | Причина эффективности                      |
| -------------------------------- | ------------------------------------------ |
| Таблицы изначально отсортированы | Нет затрат на подготовку                   |
| Есть подходящие индексы          | Можно использовать индексные сканы         |
| Большие наборы данных            | Линейный доступ и потоковая обработка      |
| Ограниченная память              | Требует небольших буферов после сортировки |

### Ключевая характеристика

Алгоритм не делает случайных дисковых обращений, а значит **особенно выгоден на больших наборах данных**.

---

# Когда его применение затруднено

| Проблема                  | Причина                                 |
| ------------------------- | --------------------------------------- |
| Нет сортировки и индексов | Необходимо выполнить сортировку заранее |
| Маленькие выборки         | Nested Loop может быть быстрее          |
| Неоптимальные буферы      | Сортировка может стать узким местом     |

Merge join выбирают там, где **упорядоченность данных становится ресурсом**.

---

# Итог

Merge join — это алгоритм, выросший из уважения к физике хранения данных.

Если данные уже отсортированы — соединение выполняется с почти идеальной линейной сложностью. Если нет — сортировка превращается в "инвестицию", окупающуюся на больших объёмах.

---

# Связанные темы

- [TPMMS](/Nodes/Algorithms/IO_Model/TPMMS.md)
- [Nested Join](./Nested_Join.md)
- [Merge Join](./Hash_Join.md)
- [Буферный менеджер](/Nodes/DataManagement_and_Storage/DBMS/Fundamental/Components/Buffer_Manager/Buffer_Manager.md)

---
