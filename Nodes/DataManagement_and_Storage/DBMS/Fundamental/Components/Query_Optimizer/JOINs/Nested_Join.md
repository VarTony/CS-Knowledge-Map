---
title: Nested Loop Join (NLJ)
---


# Место среди алгоритмов соединения

В реляционно подобных СУБД существует три фундаментальных алгоритма соединения:

| Алгоритм             | Суть                          | Когда хорош                                 |
| -------------------- | ----------------------------- | ------------------------------------------- |
| **Nested Loop Join** | Перебор + поиск сопоставлений | Малые таблицы / высокоселективные фильтры / |
| Индекс по ключу      |                               |                                             |
| **Hash Join**        | Построить хэш, затем искать   | Большие объёмы, мало памяти, equi-join      |
| **Merge Join**       | Отсортировать и слить потоки  | Уже отсортированы / крупные таблицы         |

**Nested Loop Join** — самый старый и простой механизм. Его придумали ещё в первые годы коммерческих СУБД, когда диски были медленными, память — дорогой, а индексы — редкостью.

Интуитивный смысл:

> «Для каждой строки слева — найти подходящие строки справа»

Это буквально *вложенный цикл*, поэтому и название — **nested loop**.

---

# Базовая идея

Пусть есть две таблицы: R и S.

```text
for each row r in R:
    for each row s in S:
        if r.key == s.key:
            output(r,s)
```

Если **нет индекса**, программа просто перебирает *всех со всеми* → `O(T(R) * T(S))`.

Если **есть индекс по ключу S.key**, алгоритм превращается в:

```text
for each row r in R:
    lookup matching rows in S via index
```

Это резко ускоряет выполнение, превращая внешний цикл в перебор R, а поиск по S — в **быстрый индексный доступ**.

---

# Почему иногда это самый быстрый способ

Хотя nested loop звучит как наивный перебор, он силён там, где:

* R **маленькая**
* есть **индекс** по ключу в S
* высокоселективное условие (мало совпадений)
* уже есть буферизация страниц
* строки S лежат «рядом» (локальность данных)

Такие случаи часто встречаются в OLTP:

* «найти покупки одного пользователя»
* «достать 5 последних операций по счёту»
* «проверить доступы»

Не стоит сканировать миллион строк, если ищем ровно *пять*.

---

# Взаимодействие с буферным менеджером

| Действие                   | Где идёт работа                    |
| -------------------------- | ---------------------------------- |
| Последовательный перебор R | Буфер может удерживать страницы R  |
| Индексный поиск в S        | Чтение index pages + heap pages    |
| Кэш попадается удачно      | Большая часть S может не грузиться |

**NLJ выигрывает**, если S уже в буфере или читается точечно.

---

# Формулы оценки

### Без индекса:

```
I/O ≈ B(R) + T(R) * B(S)
```

Очень дорого для больших S.

### С индексом (index nested loop):

```
I/O ≈ B(R) + T(R) * (индекс-доступ + чтение нужных строк)
```

Если `T(R)` мало и индекс эффективен → отлично.

---

# Когда nested loop плох

| Ситуация             | Почему плохо           |
| -------------------- | ---------------------- |
| Обе таблицы большие  | Комбинаторный взрыв    |
| Нет индекса          | Полный перебор         |
| Селективность низкая | Много скачков по диску |

В аналитике (OLAP) почти всегда выигрывает hash join или merge join.

---

# Оптимизатор и выбор NLJ

PostgreSQL выберет nested loop, если:

* `enable_nestloop = on` (по умолчанию)
* оценивает R как маленькую
* есть индекс по S.key
* фильтры сильно режут результат

И наоборот — **не выберет**, если таблицы крупные и hash join дешевле.

---

# Итог

* NLJ = *вложенный цикл*, древний и фундаментальный
* Отличен в OLTP, слаб в OLAP
* Раскрывает силу индексов
* Лаконичен, прост, надёжен, когда данные малы и задача точечная

> «Если R маленькая и есть индекс на S — NLJ может быть лучшим выбором»

---

# Связанные темы

- [Hash Join](./Hash_Join.md)
- [Merge Join](./Merge_Join.md)
- [Буферный менеджер](/Nodes/DataManagement_and_Storage/DBMS/Fundamental/Components/Buffer_Manager/Buffer_Manager.md)
