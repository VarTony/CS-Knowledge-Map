---
title: Однопроходный алгоритм
---

# Однопроходный алгоритм

1970, СУБД только начинали выходить из лабораторий IBM и Berkeley, их главной проблемой были не вычислительные мощности процессора, а работа с **диском**. Чтение с диска занимало миллисекунды — 'вечность' по сравнению с обращением к памяти. Чтобы обработать данные эффективно, нужно  не просто “читать таблицу”, а **читать её так, чтобы везвращаться к диску как можно реже**.

Так возникла идея: если хотя бы одна таблица помещается в оперативную память, **можно обработать всё отношение, делая только один проход по второй таблице**. Это и есть однопроходный (one-pass) алгоритм — фундаментальная стратегия для многих сегодняшних СУБД, которая лежит в основе соединений, группировки и устранения дубликатов.

---

## Архитектура памяти: три буфера

Чтобы понимать алгоритм, нужно видеть его глазами СУБД, а не программиста SQL.

| Буфер                | Роль                                                      |
|---------------------|-----------------------------------------------------------|
| **Входной буфер**   | Загружает страницы (pages) из большой таблицы             |
| **Промежуточный**   | Хранит данные малого отношения или структуру (хэш-таблица, B-дерево) |
| **Выходной буфер**  | Накопление результатов перед записью или передачей наверх |

Каждый буфер — это физический слот в buffer pool, закреплённый за страницей. СУБД оперирует не в терминах строк — она манипултрует страницами.

---

# Как работает однопроходный алгоритм

### **Шаг 1. Загрузка малого отношения в память**
Если таблица S занимает 10 страниц, а у СУБД есть, скажем, 12 свободных буферов — она загружает **всё отношение S целиком**.
Данные либо хранятся как массив кортежей, либо перегружаются в **структуру для быстрого поиска**:

- Для DISTINCT — это хэш-таблица (hash table)
- Для GROUP BY и JOIN — это дерево или тот же хэш

---

### **Шаг 2. Последовательное сканирование большой таблицы**
Таблица R может занимать тысячи страниц. Но мы читаем её **по одной странице**:


## Однопроходный алгоритм (Volcano Model)

### **Фаза 1 — open()**

Инициализация оператора:

```
* Выделяется память под промежуточный буфер (in-memory structure).
* Малая таблица полностью считывается в память.
* Структура наполняется:

  * Для JOIN → строится хэш-таблица, если нет B-индекса и предикат предполагает = или !=
  * Для GROUP BY → хэш ключ → агрегат
  * Для DISTINCT → множество уникальности, - хэш-таблица
* Итератор над большой таблицей открывается, позиция установлена на первую страницу.


open():
    allocate_memory()
    for each page in S:                // S – малая таблица
        load page into buffer
        for each tuple s:
            insert into in_memory_structure(s)
        // Тут же может быть создана хэш таблица если не предусмотрено B индекса таблицы
    open iterator on R                // R – большая таблица

 ```
---

### **Фаза 2 — get-next() (сердце алгоритма)**

Это непрерывный поток, который читает одну страницу за другой и сопоставляет её с содержимым памяти.

```
get-next():
    while iterator S has more data:
        load next page of S into input buffer
        for each tuple s in page:
            if match(s, in_memory_structure):
                return (s JOIN r)     // или (агрегат обновлён)
    // Если это OUTER JOIN — после потоковой части:
    if OUTER and remaining tuples in memory not matched:
        return (r, NULL)
    else:
        return EOF   // Возврат данных
```

**Именно эта фаза обеспечивает «однопроходность»** — каждая страница R читается ровно один раз.
**Пространство памяти не меняется** — служит постоянным контекстом, с которым сравнивается входящий поток.

---

### **Фаза 3 — close()**

* Освобождение буферов
* Сброс временных структур
* Завершение оператора

```
close():
    free(in_memory_structure)
    close iterator on R
```

---

## Краткое резюме эксплуатации буферов по фазам

| Фаза         | Действие                                              | Буферы задействованы                                                        |
| ------------ | ----------------------------------------------------- | --------------------------------------------------------------------------- |
| **open**     | Загрузка малого отношения                             | входной буфер (для чтения страниц S), промежуточный буфер                   |
| **get-next** | Потоковое чтение большого отношения, сравнение, вывод | входной буфер (страницы R), промежуточный буфер (постоянно), выходной буфер |
| **close**    | Освобождение ресурсов                                 | все буферы очищаются                                                        |

```

Здесь проявляется **итераторная модель (iterator model)** — данные обрабатываются, как поток:
`open → next → next → next → close`.

---

# Универсальная схема для всех операций (При отсутствии B-индекса)

| Операция          | Что в памяти             | Как используется промежуточный буфер |
|-------------------|--------------------------|--------------------------------------|
| **JOIN**          | Малая таблица + хэш      | Быстрый поиск по ключу               |
| **GROUP BY**      | Хэш (ключ → агрегат)     | Накапливает суммы, счётчики и т.д.   |
| **DISTINCT**      | Хэш уникальности         | Проверяет, был ли кортеж             |
| **ELIMINATE DUP** | То же, что DISTINCT      | Отбрасывает повтор                   |

> Всё это один и тот же алгоритм:
> **“удержать часть данных в памяти, пройти по остальным ровно один раз”**.

---

# Почему это революционно

- **Диск читается один раз** — мы избегаем дорогостоящих обратных переходов.
- **Память используется как фильтр** — СУБД **мемоизирует** состояние.
- **Производительность зависит только от скорости последовательного чтения.**
- **Это единственный физический(внешний) алгоритм, который масштабируется линейно**, пока малая таблица помещается в память.

---

# Как СУБД решает, можно ли применить однопроходный алгоритм

Перед выполнением запроса планировщик оценивает:
- Размер отношений (в страницах и кортежах)
- Объём доступной памяти (work_mem)
- Селективность фильтрации

Если меньшая таблица *влезает* в выделенную память → используется однопроходный алгоритм.  
Если *не влезает* → переход к двухпроходным (hash join с разбиением, sort-merge и т.д.).

---

# Однопроходное соединение (как частный случай)

Допустим, у нас:

```

S – малая таблица
R – большая таблица

```

Алгоритм:

1. Загрузить S целиком в память, построить хэш (ключ → tuple list).
2. Открыть потоковое чтение R.
3. Для каждой строки из R искать совпадение в хэше.
4. Если JOIN типа LEFT — дополнительно выписать строки из S, которые не дали совпадений.

Это **Natural Join + NULL-дополнение как постобработка**.

---

# Итог

Однопроходный алгоритм — это фундаментальный механизм исполнения запросов в СУБД.  
Он не “частный случай JOIN”, не “способ группировки” — **он первичен**. Все перечисленные операции — всего лишь разные сценарии использования **одного и того же буферного цикла**.

> **Память удерживает суть**  
> **Диск поставляет поток**  
> **Один проход решает задачу**

---

## Связанные темы

- [Модель итератора (Volcano-style execution)](./Iterator_Model.md)
- [Буферный менеджер и page replacement](/Nodes/DataManagement_and_Storage/DBMS/Fundamental/Components/Buffer_Manager.md)