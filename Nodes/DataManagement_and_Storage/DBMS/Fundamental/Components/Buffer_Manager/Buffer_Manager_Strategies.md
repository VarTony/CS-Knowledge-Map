---
title: Стратегии управления буферным пулом
---


# Буферный менеджер: как СУБД решает, какие страницы удерживать в памяти

##  Проблематика

Скорость СУБД, как правило, определяется не скоростью CPU, а тем, насколько удачно она удерживает нужные страницы в памяти.
Именно поэтому в ранних научных статьях и инженерных отчётах встречаются первые прототипы LRU и упрощённых его вариантов: они обсуждались как методы «предсказания локальности», которые позволяли уменьшить число дисковых обращений без изменения логики запросов.
Часовая стратегия (Clock) — более поздняя, практическая оптимизация (первые упоминания — начало 80-х), созданная как дешёвая альтернатива LRU для многопользовательских систем. Clock быстро вытеснила классический LRU в промышленных СУБД благодаря своей устойчивости к конкуренции потоков.

---

# Почему стратегии вытеснения — это один из столпов в архитектуре СУБД

Буферный пул — это «операционная система внутри операционной системы». Он решает три задачи:

1. **Какой блок загрузить?**
   Данные читаются с диска крупными кусками — страницами, и каждый такой блок должен занять место в пуле.

2. **Какой блок вытеснить?**
   Если пул заполнен, система обязана выбрать "жертву", не нарушив работу запросов.

3. **Когда записывать изменения на диск?**
   Страница может содержать несохранённые изменения, поэтому её нельзя просто выбросить.

---

# Основные стратегии вытеснения

---

# **1. LRU — Least Recently Used**

### Предположение

Страница, которую давно не читали, вероятно, скоро не понадобится.


### Реализация

Менеджер ведёт список страниц, отсортированный по времени последнего доступа.
При необходимости вытесняет хвост списка.

### Проблемы

* **Последовательное сканирование убивает кэш:** длинный Seq Scan может вытеснить весь пул.
* **Стоимость обновления списка:** поддержание порядка требует дополнительных структур.

---

# **2. Clock (часовая стрелка)**

### Предположение

Это LRU, но «приближённый» — менее точный, но гораздо дешевле.

### Исторический мотив

Инженерам нужно было решение, работающее в условиях высокой конкуренции и без дорогостоящих структур. Так появилась часовая схема: простая, однопроходная, выдерживающая нагрузки.

### Как работает

Буферный пул рассматривается как кольцо — как циферблат.

У каждой страницы есть одно поле — **бит использования**:

* при обращении к странице бит становится **1**;
* когда стрелка проходит мимо страницы:

  * если бит равен **0** → страница вытесняется;
  * если **1** → бит сбрасывается в 0, а страница получает «второй шанс».

### Почему это эффективно

* минимальные накладные расходы,
* хорошая устойчивость под смешанными нагрузками,
* отсутствие длинных цепочек обновлений как в LRU.

Для PostgreSQL **Clock — базовая стратегия**, вокруг которой построены все последующие.

---

# **3. Clock-Sweep (модификация PostgreSQL)**

Часовой алгоритм в PostgreSQL не двоичен. Вместо бита используется **счетчик «полезности»** страницы.

### Логика

Каждый запрос повышает этот счётчик.
Когда система ищет страницу для вытеснения, она:

1. проходит по кольцу,
2. уменьшает счетчик на 1,
3. вытесняет те, что стали равны 0.

### Зачем так сделали

Например, если у нас в буфер загружена страница с корневыми узлами индекса, очевидно, что скорее всего она будет часто использоваться, для того чтобы не выгружать и не загружать ее вновь в память, ей навешивается высокая значимость(может условно(дескретность вычислительных машин) стремиться к бесконечности), таким образом дефакто часто используемая страница может зарезирвировать для себя постоянное место в памяти.

Это даёт **более стабильную работу под реальной OLTP-нагрузкой**.
PostgreSQL исторически выбрал Clock-Sweep как золотую середину.

---

# **4. MRU — Most Recently Used**

### Предположение

Иногда свежие страницы наоборот не нужны повторно.

### Где применяется

* операции слияния,
* крупные Seq Scan,
* одноразовые таблицы.

MRU полезен, когда запрос читает данные один раз и никогда не возвращается к ним.

Некоторые СУБД автоматически переключаются в MRU-поведение во время большого последовательного чтения.

PostgreSQL реализует это через **режимы доступа** и подсказки оптимизатора, а не отдельной глобальной политикой.

---

# **5. 2Q, LRU-K и другие «двухкоридорные» стратегии**

### Предпосылки

LRU слишком груб. Он не различает:

* страницу, которую использовали дважды за три секунды,
* и страницу, к которой попали один раз случайно.

Двухуровневые схемы решают это.

### Принцип

1. **Q1** — очередь «подозреваемых», в которую попадают новые страницы.
   Если страница здесь долго не используется — её вытесняют первой.

2. **Q2** — очередь «подтверждённой полезности».
   Попасть туда можно только после нескольких обращений.

СУБД, использующие 2Q или LRU-K, более точно различают рабочие наборы и временные.

---

## Buffer Replacer Hints: подсказки оптимизатора**

Современные СУБД позволяют уровню планирования сигнализировать буферному менеджеру о намерениях запроса:

* «эта страница будет использована один раз»,
* «эти таблицы — часто используемые, держи их в памяти»,
* «этот план требует локальной последовательности».

PostgreSQL применяет это через:

* `vacuum_cost_delay`,
* `ring buffers` (специальные циклические буферы для Seq Scan),
* механизм `usage_count`,
* подсказки сканам.

Это минимизирует конфликты между OLTP и тяжёлой аналитикой.

---

# Как СУБД выбирает, что вытеснять (общая схема)

```
Буфер заполнен →
  если страница "грязная" → записать WAL + flush →
  применить политику вытеснения →
  освободить слот →
  загрузить новую страницу
```

Буферный менеджер должен учитывать:

* изоляцию транзакций,
* журналирование,
* параллельное выполнение запросов,
* перезапуски и аварии,
* собственную политику вытеснения.

---

# Итог

Стратегии вытеснения страниц — это внутренний механизм, который позволяет СУБД работать быстрее дисковой подсистемы:

* **LRU** — интуитивно просто, но чувствительно к последовательным сканам.
* **Clock** — лёгкая и устойчивая альтернатива LRU.
* **Clock-Sweep (PostgreSQL)** — адаптивное поведение с учетом востребовательности страниц.
* **MRU** — точечная оптимизация для одноразовых сканов.
* **2Q / LRU-K** — расширенные LRU для высоких нагрузок.

* **Подсказки оптимизатора** — связь планировщика и буферного менеджера.

---

## Связанные темы

- [Буфер-менеджер](./Buffer_Manager.md)